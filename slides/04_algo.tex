\documentclass[xcolor={rgb,x11names,svgnames},rgb,x11names,svgnames]{beamer}

%\includeonlyframes{blasdata}

\usepackage[T1]{fontenc}
\usepackage{cellspace}

\usepackage{amsmath}
\DeclareMathOperator*{\argmax}{arg\,max}

\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{xspace}
\usepackage[normalem]{ulem}
\usepackage{minted}
\definecolor{codebg}{rgb}{0.95,0.95,0.95}
\setminted{bgcolor=codebg}
\usepackage{changepage}

\newenvironment{wider}{%
\begin{adjustwidth}{-0.6cm}{}%
  \begin{minipage}{12cm}%
}{%
\end{minipage}%
\end{adjustwidth}%
}

\usepackage{ifthen}


\usepackage{marvosym}
\usepackage{pifont}
%\usepackage[rgb]{xcolor}

\newcommand{\bigO}[1]{\ensuremath{\mathcal{O}\left( #1 \right)} }
\newcommand{\bigOmega}[1]{\ensuremath{\Omega\left( #1 \right)} }

\newcommand{\red}{\alert}
\newcommand{\green}{\color{LimeGreen}}
\newcommand{\blue}{\color{cyan}}

% FORTIN
\newcommand{\mynote}[1]{\note<1>[item]{#1}}
\newcommand{\euro}{\EUR\xspace}

\usetikzlibrary{patterns}
\usetikzlibrary{snakes}
 \usetikzlibrary{arrows}
\usetikzlibrary{backgrounds}
\usetikzlibrary{shapes}
\usetikzlibrary{shadows}
\usetikzlibrary{shadings}
\usetikzlibrary{calc}
\usetikzlibrary{decorations}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{decorations.shapes}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{positioning}
\usetikzlibrary{math}

\definecolor{amethyst}{rgb}{0.6, 0.4, 0.8}
\definecolor{cyan}{rgb}{0,0.6796875,1}

\usecolortheme{rose}
\setbeamertemplate{footline}{}
\setbeamertemplate{navigation symbols}{}

  \newcommand{\tikzmat}[2] {
\draw[thick] let \p1 = (#1 |- #2),
                 \p2 = (#2 |- #1) in
   ($ (#1) + (0.05,-0.1) $) -- ++(-0.15, 0)  -- ($ (\p1) + (-0.1,0.1) $) -- ++(0.15,0)
   ($ (\p2) + (-0.05,-0.1) $) -- ++(0.15, 0) -- ($ (#2) + (0.1,0.1) $) -- ++(-0.15,0);
}
  


\usepackage{fontspec}

\setsansfont{PalatinoSansLTPro}[
   Path = /home/charles/charles_work/fonts/PalatinoSans/, 
   Extension      = .otf,
   UprightFont    = *-Regular,
   BoldFont= *-Bold ,
   ItalicFont = *-Italic,
   BoldItalicFont = *-BoldIta
]

\title{Lecture 4: Common Algorithmic Themes}

\begin{document}

\begin{frame}[label=title]
  \titlepage
\end{frame}

\section{Généralités}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{How to Write Efficient Parallel Programs?}

\begin{block}{General principles}

\begin{itemize}
\item \textbf{Data locality}: minimize communications by placing data near the CPUs that need them

\medskip

\item \textbf{load balancing}: minimize periods of inactivity

\medskip

\item \textbf{Overlap communication with computation}: avoid processors sitting
  idle while transferring data
\end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Load balancing}

  ``Load balancing'' = who does what? = affecting tasks to CPU
  
  \begin{exampleblock}{Predictable workload}
    \begin{itemize}
    \item[$\Rightarrow$] \textbf{Static} job affectation
      \begin{itemize}
      \item[$=$] Can be determined in advance, fixed over time
      \end{itemize}
      
    \item Typical scenario: 
      \begin{itemize}
      \item All data requiring the same amount of computation time
      \item[$\rightarrow$] Distributed by block, cyclic, \dots
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
  
  \medskip
  
  \begin{alertblock}{Unpredictable workload}
    \begin{itemize}
    \item[$\Rightarrow$] \textbf{Dynamic} load balancing
      \begin{itemize}
      \item Affectation of tasks to processes \emph{during} the computation
      \end{itemize}
    \item \sout{Master-slave} Boss-worker paradigm
    \item ``Work stealing'' paradigm
    \end{itemize}
  \end{alertblock}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{\sout{Master-Slave} Boss-Worker  Model}

  \begin{itemize}
  \item The boss knows the data and the work to be done
  \item Available workers ask for work
  \item The boss sends tasks (or orders the workers to stop)
    \begin{alertblock}{Limitations}
      \begin{itemize}
      \item The boss needs a lot of RAM if they have to load all the data
      \item 2 message exchanges per task (A/R) $\longrightarrow$ high granularity
      \item Too many workers $\rightarrow$ the boss becomes a bottleneck
      \end{itemize}
    \end{alertblock}
    
    \begin{exampleblock}{Advantages~:}
      \begin{itemize}
      \item Good load balancing, even with heterogeneous resources (or availability/speed that varies with time)
      \item \emph{Checkpointing} is very easy (checkpoint the boss)
      \end{itemize}
    \end{exampleblock}
  \end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Work-Stealing Model}

  \begin{exampleblock}{Principle}
    
    \begin{itemize}
    \item Each processor manages their own work list
      
      \begin{itemize}
      \item \textit{A priori} fair initial distribution
      \end{itemize}
      
    \item If task list is empty :
      \begin{itemize}
      \item Choose a \emph{victim} (randomly?)
      \item ``Steal'' a fraction (50\% ?) of the victim's remaining work
      \end{itemize}
    \end{itemize}
  \end{exampleblock}
  
  \bigskip
  
  \begin{itemize}
  \item [+] Completely symmetrical
    \begin{itemize}
    \item ``\textit{No gods, no masters}'' \CircledA
    \end{itemize}
    
  \item [+] Every process participates in the calculation
    \begin{itemize}
    \item No \sout{parasite} bosses twiddling their thumbs
      
    \end{itemize}
  \item [--] not easy to detect when the computation is terminated
  \item [--] difficult to program
  \item [--] difficult to \emph{checkpoint}
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Overlapping Communication and Computation}

  \begin{tikzpicture}
    % initial 
    \draw[thick, ->] (-0.5, 0) -- (8.5, 0) node[right] {time};
    \foreach \i in {0, 1, 2, 3, 4}  {
      % longer comms
      \fill<1>[fill=LimeGreen, nearly transparent] (\i*1.5cm, -0.25) rectangle +(1, 0.5);
      \fill<1>[fill=red, nearly transparent] (\i*1.5cm + 1cm, -0.25) rectangle +(0.5, 0.5);
      % longer comms
      \fill<2>[fill=LimeGreen, nearly transparent] (\i*1.5cm, -0.25) rectangle +(0.25, 0.5);
      \fill<2>[fill=red, nearly transparent] (\i*1.5cm + 0.25cm, -0.25) rectangle +(1.25, 0.5);
    }
    \foreach \i in {0, 1, 2, 3, 4, 5} {
      \draw[thick] (\i*1.5cm, -0.25) -- +(0, 0.5);
    }

    \begin{scope}[yshift=-2cm]
      % overlap, longer compute
      \draw<1>[thick, ->] (-0.5, 0) -- (6, 0);
      \draw<2>[thick, ->] (-0.5, 0) -- (7, 0);
      \foreach \i in {0, 1, 2, 3, 4}  {
        \fill<1>[fill=LimeGreen, nearly transparent] (\i*1cm, 0) rectangle +(1, 0.5);
        \fill<1>[fill=red, nearly transparent] (\i*1cm, -0.5) rectangle +(0.5, 0.5);

        \fill<2>[fill=LimeGreen, nearly transparent] (\i*1.25cm, 0) rectangle +(0.25, 0.5);
        \fill<2>[fill=red, nearly transparent] (\i*1.25cm, -0.5) rectangle +(1.25, 0.5);

      }
      \foreach \i in {0, 1, 2, 3, 4, 5} {
        \draw<1>[thick] (\i*1cm, -0.5) -- +(0, 1);
        \draw<2>[thick] (\i*1.25cm, -0.5) -- +(0, 1);
      }
    \end{scope}
  
    \begin{scope}[xshift=2cm]   % legend
      \fill[fill=LimeGreen, nearly transparent] (1, 1) rectangle +(3, 0.5);
      \path (1, 1) rectangle node[font=\small] {compute} +(3, 0.5);

      \fill[fill=red, nearly transparent] (1, 1.5) rectangle +(3, 0.5);
      \path (1, 1.5) rectangle node[font=\small] {communicate} +(3, 0.5);
    \end{scope}
  \end{tikzpicture}

  \begin{block}{\vspace*{-3ex}}
    \vspace*{-1em}
    \begin{align*}
      T &= T_{comp} + T_{comm} & \text{(before)} \\
      T'&= \max(T_{comp}, T_{comm}) & \text{(after)} \\
        &\geq T/2
    \end{align*}
    \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile=singleslide]
  \frametitle{Data Parallelism}

  \begin{block}{Classic example: \emph{map}}
\begin{minted}{C}
for (int i = 0; i < n; i++)
         B[i] = f(A[i], i)
\end{minted}
  \end{block}

  \bigskip

  \begin{itemize}
  \item No need for communication / synchronization between processes!
  \item Data distribution?
  \item Load balancing?
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Distribution de données}

\begin{frame}[fragile=singleslide]
\frametitle{1D Distribution}

By blocs:

\medskip

\begin{tikzpicture}
  \filldraw[fill=red]    (0, 0) rectangle  +(1,1);
  \filldraw[fill=orange] (1, 0) rectangle  +(1,1);
  \filldraw[fill=yellow] (2, 0) rectangle  +(1,1);
  \filldraw[fill=green]  (3, 0) rectangle  +(1,1);
  \filldraw[fill=cyan]   (4, 0) rectangle  +(1,1);
  \filldraw[fill=blue]   (5, 0) rectangle  +(1,1);
  \filldraw[fill=magenta] (6, 0) rectangle  +(1,1);
  \filldraw[fill=violet] (7, 0) rectangle +(1,1);
  \filldraw[fill=lightgray] (8, 0) rectangle +(1,1);
  \filldraw[fill=darkgray] (9, 0) rectangle +(1,1);
  
  \draw[thick] (0, 0) rectangle (10, 1);
  \foreach \i in {0.2, 0.4, ..., 9.8}
  \draw (\i, 0) -- +(0, 1);
\end{tikzpicture}

\begin{itemize}
\item Easiest !
\item Favored by MPI
\end{itemize}

\vspace{1cm}

Cyclic

\medskip

\begin{tikzpicture}
  \foreach \i in {0, 2, 4, 6, 8} {
    \filldraw[fill=red]    (\i, 0) rectangle  +(0.2,1);
    \filldraw[fill=orange]    (\i + 0.2, 0) rectangle  +(0.2,1);
    \filldraw[fill=yellow]    (\i + 0.4, 0) rectangle  +(0.2,1);
    \filldraw[fill=green]    (\i + 0.6, 0) rectangle  +(0.2,1);
    \filldraw[fill=cyan]    (\i + 0.8, 0) rectangle  +(0.2,1);
    \filldraw[fill=blue]    (\i + 1, 0) rectangle  +(0.2,1);
    \filldraw[fill=magenta]    (\i + 1.2, 0) rectangle  +(0.2,1);
    \filldraw[fill=violet]    (\i + 1.4, 0) rectangle  +(0.2,1);
    \filldraw[fill=lightgray]    (\i + 1.6, 0) rectangle  +(0.2,1);
    \filldraw[fill=darkgray]    (\i + 1.8, 0) rectangle  +(0.2,1);
  }
  % \filldraw[fill=red]    (0, 0) rectangle  +(1,1);
  % \filldraw[fill=orange] (1, 0) rectangle  +(1,1);
  % \filldraw[fill=yellow] (2, 0) rectangle  +(1,1);
  % \filldraw[fill=green]  (3, 0) rectangle  +(1,1);
  % \filldraw[fill=cyan]   (4, 0) rectangle  +(1,1);
  % \filldraw[fill=blue]   (5, 0) rectangle  +(1,1);
  % \filldraw[fill=magenta] (6, 0) rectangle  +(1,1);
  % \filldraw[fill=violet] (7, 0) rectangle +(1,1);
  % \filldraw[fill=lightgray] (8, 0) rectangle +(1,1);
  % \filldraw[fill=darkgray] (9, 0) rectangle +(1,1);
  
  \draw[thick] (0, 0) rectangle (10, 1);
  \foreach \i in {0.2, 0.4, ..., 9.8}
  \draw (\i, 0) -- +(0, 1);
\end{tikzpicture}

\begin{itemize}
\item May improve load balancing
\item Also possible with MPI
  \begin{itemize}
  \item Must create ``types'' $\leadsto$ \mintinline{C}{MPI_Type_vector}...
  \end{itemize}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{1D Distribution of 2D Data}

By blocs:

\medskip

\begin{tikzpicture}[scale=0.5]
  \filldraw[fill=red]    (0, 0) rectangle  +(12,3);
  \filldraw[fill=orange] (0, 3) rectangle  +(12,3);
  \filldraw[fill=green] (0, 6) rectangle  +(12,3);
  \filldraw[fill=cyan]  (0, 9) rectangle  +(12,3);
  
  \draw[thick] (0, 0) rectangle (12, 12);
  \foreach \i in {1, 2, ..., 11} {
    \draw (\i, 0) -- +(0, 12);
    \draw (0, \i) -- +(12, 0);
  }
\end{tikzpicture}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{1D Distribution of 2D Data}

Cyclic:

\medskip

\begin{tikzpicture}[scale=0.5]
  \foreach \i in {0, 4, 8} {
    \filldraw[fill=red]    (0, \i) rectangle  +(12,1);
    \filldraw[fill=orange] (0, 1+\i) rectangle  +(12,1);
    \filldraw[fill=green] (0, 2+\i) rectangle  +(12,1);
    \filldraw[fill=cyan]  (0, 3+\i) rectangle  +(12,1);
  }
  \draw[thick] (0, 0) rectangle (12, 12);
  \foreach \i in {1, 2, ..., 11} {
    \draw (\i, 0) -- +(0, 12);
    \draw (0, \i) -- +(12, 0);
  }
\end{tikzpicture}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{2D Distribution of 2D Data}

By blocs:

\medskip

\begin{tikzpicture}[scale=0.5]
  \filldraw[fill=red]    (0, 0) rectangle  +(6, 6);
  \filldraw[fill=orange] (0, 6) rectangle  +(6,6);
  \filldraw[fill=green] (6, 0) rectangle  +(6,6);
  \filldraw[fill=cyan]  (6, 6) rectangle  +(6,6);

  \draw[thick] (0, 0) rectangle (12, 12);
  \foreach \i in {1, 2, ..., 11} {
    \draw (\i, 0) -- +(0, 12);
    \draw (0, \i) -- +(12, 0);
  }
\end{tikzpicture}
\end{frame}

%%%%%%%%%%

\begin{frame}
\frametitle{2D Distribution of 2D Data}

Cyclic:

\medskip

\begin{tikzpicture}[scale=0.5]
  \foreach \i in {0, 2, 4, 6, 8, 10} {
    \foreach \j in {0, 2, 4, 6, 8, 10} {
      \filldraw[fill=red]    (\i, \j) rectangle  +(1, 1);
      \filldraw[fill=orange] (\i, 1+\j) rectangle  +(1,1);
      \filldraw[fill=green] (\i+1, \j) rectangle  +(1,1);
      \filldraw[fill=cyan]  (\i+1, 1+\j) rectangle  +(1,1);
    }
  }
  \draw[thick] (0, 0) rectangle (12, 12);
  \foreach \i in {1, 2, ..., 11} {
    \draw (\i, 0) -- +(0, 12);
    \draw (0, \i) -- +(12, 0);
  }
\end{tikzpicture}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{2D Distribution of 2D Data}

Block-Cyclic:

\medskip

\begin{tikzpicture}[scale=0.5]
  \foreach \i in {0, 4, 8} {
    \foreach \j in {0, 4, 8} {
      \filldraw[fill=red]    (\i, \j) rectangle  +(2, 2);
      \filldraw[fill=orange] (\i, 2+\j) rectangle  +(2,2);
      \filldraw[fill=green] (\i+2, \j) rectangle  +(2,2);
      \filldraw[fill=cyan]  (\i+2, 2+\j) rectangle  +(2,2);
    }
  }
  \draw[thick] (0, 0) rectangle (12, 12);
  \foreach \i in {1, 2, ..., 11} {
    \draw (\i, 0) -- +(0, 12);
    \draw (0, \i) -- +(12, 0);
  }
\end{tikzpicture}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{1D Distribution of 3D Data}

\centering\includegraphics[height=8cm]{slabs.png}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{2D Distribution of 3D Data}

\centering\includegraphics[height=8cm]{pencils.png}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile=singleslide]
\frametitle{Data Parallelism (continued)}


\begin{block}{Classic example: \emph{reduce}}
\begin{minted}{C}
sum = 0
for (int i = 0; i < n; i++)
    sum = sum + A[i]
\end{minted}
\end{block}

\bigskip

\begin{itemize}
\item Data dependency on \mintinline{C}{sum}? Easy to bypass
\item Distributed memory $\rightarrow$ communications
\item Binomial tree algorithm
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile=singleslide]
  \frametitle{MPI in action: \texttt{reduce}}

  \begin{tikzpicture}
    \filldraw[fill=red]    (0, 0) rectangle  +(1,1);
    \filldraw[fill=orange] (1, 0) rectangle  +(1,1);
    \filldraw[fill=yellow] (2, 0) rectangle  +(1,1);
    \filldraw[fill=green]  (3, 0) rectangle  +(1,1);
    \filldraw[fill=cyan]   (4, 0) rectangle  +(1,1);
    \filldraw[fill=blue]   (5, 0) rectangle  +(1,1);
    \filldraw[fill=magenta] (6, 0) rectangle  +(1,1);
    \filldraw[fill=violet] (7, 0) rectangle +(1,1);
    \filldraw[fill=lightgray] (8, 0) rectangle +(1,1);
    \filldraw[fill=darkgray] (9, 0) rectangle +(1,1);
    \draw[thick] (0, 0) rectangle (10, 1);
    \foreach \i in {0.2, 0.4, ..., 9.8}
    \draw (\i, 0) -- +(0, 1);
  \end{tikzpicture}
  
  \bigskip

\begin{minted}[fontsize=\small]{C}
// Global array of size n
// p processes
int root = 0;
double sum = 0;
for (int i = rank * n / p; (rank + 1) * n / p; i++)
        sum += A[i];
MPI_Reduce(MPI_IN_PLACE, &sum, 1, MPI_DOUBLE, MPI_SUM,
           root, MPI_COMM_WORLD);
\end{minted}        

\begin{align*}
  T &= \frac{n}{p} + \lceil \log_2 p \rceil (\alpha + \beta)
\end{align*}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{frame}
% \frametitle{\alert{Shared}-memory \texttt{reduce}}

% \begin{tikzpicture}
%   \filldraw[fill=red]    (0, 0) rectangle  +(1,1);
%   \filldraw[fill=orange] (1, 0) rectangle  +(1,1);
%   \filldraw[fill=yellow] (2, 0) rectangle  +(1,1);
%   \filldraw[fill=green]  (3, 0) rectangle  +(1,1);
%   \filldraw[fill=cyan]   (4, 0) rectangle  +(1,1);
%   \filldraw[fill=blue]   (5, 0) rectangle  +(1,1);
%   \filldraw[fill=magenta] (6, 0) rectangle  +(1,1);
%   \filldraw[fill=violet] (7, 0) rectangle +(1,1);
%   \filldraw[fill=lightgray] (8, 0) rectangle +(1,1);
%   \filldraw[fill=darkgray] (9, 0) rectangle +(1,1);
  
%   \draw[thick] (0, 0) rectangle (10, 1);
%   \foreach \i in {0.2, 0.4, ..., 9.8}
%   \draw (\i, 0) -- +(0, 1);
% \end{tikzpicture}

% \bigskip

% \begin{enumerate}
% \item Tableau \texttt{Scratch} de taille $p$.
% \item $P_i$ fait : $\texttt{Scratch[i]} \gets $ somme de \emph{ses} donnée.
% \item \alert{Barrière}
% \item $P_0$ calcule la somme de \texttt{Scratch} puis l'écrit dans \texttt{sum}
% \item \alert{Barrière}
% \end{enumerate}


% \begin{align*}
%   T &= \frac{n}{p} + p \\
%     &\geq 2 \sqrt{n} & \text{(optimal atteint avec $\sqrt{n}$ processeurs)}
% \end{align*}
% \end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{frame}
% \frametitle{Algorithme (mémoire partagée) pour \texttt{reduce}}

% \begin{tikzpicture}
%   \filldraw[fill=red]    (0, 0) rectangle  +(1,1);
%   \filldraw[fill=orange] (1, 0) rectangle  +(1,1);
%   \filldraw[fill=yellow] (2, 0) rectangle  +(1,1);
%   \filldraw[fill=green]  (3, 0) rectangle  +(1,1);
%   \filldraw[fill=cyan]   (4, 0) rectangle  +(1,1);
%   \filldraw[fill=blue]   (5, 0) rectangle  +(1,1);
%   \filldraw[fill=magenta] (6, 0) rectangle  +(1,1);
%   \filldraw[fill=violet] (7, 0) rectangle +(1,1);
%   \filldraw[fill=lightgray] (8, 0) rectangle +(1,1);
%   \filldraw[fill=darkgray] (9, 0) rectangle +(1,1);
  
%   \draw[thick] (0, 0) rectangle (10, 1);
%   \foreach \i in {0.2, 0.4, ..., 9.8}
%   \draw (\i, 0) -- +(0, 1);
% \end{tikzpicture}

% \bigskip

% \begin{block}{$\texttt{reduce}(A, n):$}
%   \begin{enumerate}
%   \item Si $n = 1$, renvoyer $A[0]$.
%   \item Allouer un tableau \texttt{Scratch} de taille $n/2$.
%   \item Pour tout $0 \leq i < n/2$, faire (en parallèle):
%     \begin{itemize}
%     \item $\texttt{Scratch}[i] \gets A[2i] + A[2i+1]$.  
%     \end{itemize}
    
%   \item renvoyer : $\texttt{reduce}(\texttt{Scratch}, n/2)$.
%   \end{enumerate}
% \end{block}

% \begin{align*}
%   T &= \frac{2n}{p} + \log_2 p \\
%     &\geq 1 + \log_2 p & \text{(optimal atteint avec $n/2$ processeurs)}
% \end{align*}
% \end{frame}

\section{EDPs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Approximating Solutions of PDEs}

\begin{block}{Classic example: heat equation}
  \[
    \frac{\partial T}{\partial t} = \alpha \nabla^2 T = \alpha \left( \frac{\partial^2 T}{\partial x^2} + \frac{\partial^2 T}{\partial y^2} + \frac{\partial^2 T}{\partial z^2}\right)
  \]
  
  \begin{itemize}
  \item Heat diffusion in homogeneous material
  \item $T(x,y,z,t) = $ temperature in point $(x,y,z)$ at time $t$
  \end{itemize}
\end{block}

\medskip
\begin{alertblock}{Goal :}
\begin{itemize}
\item Compute $T(x, y, z, t)$
\item Over a finite domain
\item $T(x, y, z, 0)$ known (initial conditions)
\item Eventual boundary conditions (e.g. $T(0, y, z, t) = cst$)
\end{itemize}
\end{alertblock}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Approximating Solutions of PDEs}
\framesubtitle{Euler's Method}

  \[
    \frac{\partial T}{\partial t} = \alpha \nabla^2 T = \alpha \left( \frac{\partial^2 T}{\partial x^2} + \frac{\partial^2 T}{\partial y^2} + \frac{\partial^2 T}{\partial z^2}\right)
  \]

  \begin{exampleblock}{Approximation}
    \begin{itemize}
    \item Divide time in small intervals
      \[
        \frac{\partial T}{\partial t} \approx \frac{T(x,y, t + \Delta t) - T(x,y, t)}{\Delta t}
      \]
    \item Divide space in small ``cells''
    \end{itemize}
    \[
      \frac{\partial^2 T}{\partial x^2} \approx \frac{T(x - \Delta x,y,t) - 2 T(x,y,t) + T(x + \Delta x,y,t)}{ \Delta x^2 }
    \]
  \end{exampleblock}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Approximating Solutions of PDEs}
\framesubtitle{Euler's Method}

\begin{tikzpicture}[scale=0.4]
  \draw[ultra thick] (0, 0) rectangle (12, 12);
  \foreach \i in {1, 2, ..., 11} {
    \draw (\i, 0) -- +(0, 12);
    \draw (0, \i) -- +(12, 0);
  }

  \only<2>{
  \begin{scope}[xshift=2cm, yshift=2cm]
    % "croix" qui dépasse
    \draw[red, line width=1mm] (5, 5) -- ++(0, 1) -- ++ (-1, 0) -- ++(0, 1) --
    ++(1, 0) -- ++(0, 1) -- ++(1, 0) -- ++(0, -1) -- ++(1, 0) -- ++(0, -1) --
    ++(-1, 0) -- ++(0, -1) -- cycle;
    % petites flèches
    \draw[red,->] (5.5, 5.5) -- +(0, 0.8);
    \draw[red,->] (5.5, 7.5) -- +(0, -0.8);
    \draw[red,->] (4.5, 6.5) -- +(0.8, 0);
    \draw[red,->] (6.5, 6.5) -- +(-0.8, 0);
    \end{scope}
  }
    \fill<3>[pattern=crosshatch] (7, 8) rectangle +(1, 1);

    \node[anchor=west] at (15, 6) {``Stencil'' method};
  \end{tikzpicture}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{``Domain Decomposition'' (a.k.a. Data Parallelism)}


\begin{tikzpicture}[scale=0.4]
  \filldraw[very thick, fill=red]       (0, 8) rectangle  +(4, 4);
  \filldraw[very thick, fill=orange]    (4, 8) rectangle  +(4,4);
  \filldraw[very thick, fill=yellow]    (8, 8) rectangle  +(4,4);
  \filldraw[very thick, fill=green]     (0, 4) rectangle  +(4,4);
  \filldraw[very thick, fill=cyan]      (4, 4) rectangle  +(4,4);
  \filldraw[very thick, fill=blue]      (8, 4) rectangle  +(4,4);
  \filldraw[very thick, fill=magenta]   (0, 0) rectangle  +(4,4);
  \filldraw[very thick, fill=violet]    (4, 0) rectangle  +(4,4);
  \filldraw[very thick, fill=lightgray] (8, 0) rectangle  +(4,4);

  
  \draw[ultra thick] (0, 0) rectangle (12, 12);
  \foreach \i in {1, 2, ..., 11} {
    \draw (\i, 0) -- +(0, 12);
    \draw (0, \i) -- +(12, 0);
  }

  
  \end{tikzpicture}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}
\frametitle{``Domain Decomposition'' (a.k.a. Data Parallelism)}


\begin{tikzpicture}[scale=0.4]
  \path[use as bounding box] (1, 0) rectangle (18, 18);
  
  % gros carrés
  \filldraw[very thick, fill=red]       (0,  14) rectangle  +(4, 4);
  \filldraw[very thick, fill=orange]    (7,  14) rectangle  +(4,4);
  \filldraw[very thick, fill=yellow]    (14, 14) rectangle  +(4,4);
  \filldraw[very thick, fill=green]     (0,  7) rectangle  +(4,4);
  \filldraw[very thick, fill=cyan]      (7,  7) rectangle  +(4,4);
  \filldraw[very thick, fill=blue]      (14, 7) rectangle  +(4,4);
  \filldraw[very thick, fill=magenta]   (0,  0) rectangle  +(4,4);
  \filldraw[very thick, fill=violet]    (7,  0) rectangle  +(4,4);
  \filldraw[very thick, fill=lightgray] (14, 0) rectangle  +(4,4);
  
  % petites cases
  \foreach \i in {0, 1, 2} {
    \foreach \j in {0, 1, 2} {
      \foreach \k in {1, 2, 3} {
        \draw (7*\i + \k, 7*\j) -- +(0, 4);
        \draw (7*\i, 7*\j + \k) -- +(4, 0);
      }
    }
  }

  \fill<4->[pattern=crosshatch] (9, 8) rectangle +(1, 1);
  \fill<3->[pattern=crosshatch] (8, 8) rectangle +(1, 1);
  
  \begin{onlyenv}<4>
      \begin{scope}[xshift=5cm, yshift=2cm]
      % "croix" qui dépasse
      \draw[red, line width=1mm] (5, 5) -- ++(0, 1) -- ++ (-1, 0) -- ++(0, 1) --
      ++(1, 0) -- ++(0, 1) -- ++(1, 0) -- ++(0, -1) -- ++(1, 0) -- ++(0, -1) --
      ++(-1, 0) -- ++(0, -1) -- cycle;
      % petites flèches
      \draw[red,->] (5.5, 5.5) -- +(0, 0.8);
      \draw[red,->] (5.5, 7.5) -- +(0, -0.8);
      \draw[red,->] (4.5, 6.5) -- +(0.8, 0);
      \draw[red,->] (6.5, 6.5) -- +(-0.8, 0);
    \end{scope}
  \end{onlyenv}
  
  \begin{onlyenv}<3>
    \begin{scope}[xshift=4cm, yshift=2cm]
      % "croix"
      \draw[red, line width=1mm] (5, 5) -- ++(0, 1) -- ++ (-1, 0) -- ++(0, 1) --
      ++(1, 0) -- ++(0, 1) -- ++(1, 0) -- ++(0, -1) -- ++(1, 0) -- ++(0, -1) --
      ++(-1, 0) -- ++(0, -1) -- cycle;
      % petites flèches
      \draw[red,->] (5.5, 5.5) -- +(0, 0.8);
      \draw[red,->] (5.5, 7.5) -- +(0, -0.8);
      \draw[red,->] (4.5, 6.5) -- +(0.8, 0);
      \draw[red,->] (6.5, 6.5) -- +(-0.8, 0);
    \end{scope}
  \end{onlyenv}
  
  \begin{onlyenv}<2>
    \begin{scope}[xshift=3cm, yshift=2cm]
      % "croix"
      \draw[red, line width=1mm] (5, 5) -- ++(0, 1) -- ++ (-1, 0) -- ++(0, 1) --
      ++(1, 0) -- ++(0, 1) -- ++(1, 0) -- ++(0, -1) -- ++(1, 0) -- ++(0, -1) --
      ++(-1, 0) -- ++(0, -1) -- cycle;
      % petites flèches
      \draw[red,->] (5.5, 5.5) -- +(0, 0.8);
      \draw[red,->] (5.5, 7.5) -- +(0, -0.8);
      \draw[red,->] (4.5, 6.5) -- +(0.8, 0);
      \draw[red,->] (6.5, 6.5) -- +(-0.8, 0);
    \end{scope}
  \end{onlyenv}
  
  \filldraw<5>[fill=blue] (11, 7) rectangle  +(1,4);
  \draw<5> (11, 8) --  +(1,0);
  \draw<5> (11, 9) --  +(1,0);
  \draw<5> (11, 10) --  +(1,0);
  \draw<5> (11, 8) --  +(1,0);
  \draw<5>[very thick]      (7,  7) rectangle  +(5,4);  
\end{tikzpicture}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{``Domain Decomposition'' (a.k.a. Data Parallelism)}

\begin{minipage}[T]{7.2cm}
\begin{tikzpicture}[scale=0.4]
  \path[use as bounding box] (1, 0) rectangle (18, 18);
  
  % halos
  \begin{onlyenv}<3->
  \filldraw[fill=violet]    (4, 0) rectangle  +(1,4);
  \filldraw[fill=magenta]   (6, 0) rectangle  +(1,4);
  \filldraw[fill=lightgray] (11, 0) rectangle  +(1,4);
  \filldraw[fill=violet]    (13, 0) rectangle  +(1,4);
  \filldraw[fill=cyan]    (4, 7) rectangle  +(1,4);
  \filldraw[fill=green]   (6, 7) rectangle  +(1,4);
  \filldraw[fill=blue] (11, 7) rectangle  +(1,4);
  \filldraw[fill=cyan]    (13, 7) rectangle  +(1,4);
  \filldraw[fill=orange]    (4, 14) rectangle  +(1,4);
  \filldraw[fill=red]   (6, 14) rectangle  +(1,4);
  \filldraw[fill=yellow]    (11,14) rectangle  +(1,4);
  \filldraw[fill=orange]    (13,14) rectangle  +(1,4);
  
  \filldraw[fill=blue]      (14, 4) rectangle  +(4,1);
  \filldraw[fill=cyan]      (7, 4) rectangle  +(4,1);
  \filldraw[fill=green]      (0, 4) rectangle  +(4,1);
  \filldraw[fill=lightgray]   (14, 6) rectangle  +(4,1);
  \filldraw[fill=violet]      (7, 6) rectangle  +(4,1);
  \filldraw[fill=magenta]     (0, 6) rectangle  +(4,1);  
  \filldraw[fill=blue]      (14, 13) rectangle  +(4,1);
  \filldraw[fill=cyan]      (7, 13) rectangle  +(4,1);
  \filldraw[fill=green]      (0, 13) rectangle  +(4,1);
  \filldraw[fill=yellow]      (14, 11) rectangle  +(4,1);
  \filldraw[fill=orange]      (7, 11) rectangle  +(4,1);
  \filldraw[fill=red]      (0, 11) rectangle  +(4,1);
\end{onlyenv}

  % gros carrés
    \filldraw[very thick, fill=red]       (0,  14) rectangle  +(4, 4);
    \filldraw[very thick, fill=orange]    (7,  14) rectangle  +(4,4);
    \filldraw[very thick, fill=yellow]    (14, 14) rectangle  +(4,4);
    \filldraw[very thick, fill=green]     (0,  7) rectangle  +(4,4);
    \filldraw[very thick, fill=cyan]      (7,  7) rectangle  +(4,4);
    \filldraw[very thick, fill=blue]      (14, 7) rectangle  +(4,4);
    \filldraw[very thick, fill=magenta]   (0,  0) rectangle  +(4,4);
    \filldraw[very thick, fill=violet]    (7,  0) rectangle  +(4,4);
    \filldraw[very thick, fill=lightgray] (14, 0) rectangle  +(4,4);
  
  \begin{onlyenv}<4->
    \draw[pattern=crosshatch, pattern color=black, very thick]       (0,  14) rectangle  +(4, 4);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (7,  14) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (14, 14) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]     (0,  7) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]      (7,  7) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]      (14, 7) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]   (0,  0) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (7,  0) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick] (14, 0) rectangle  +(4,4);
  \end{onlyenv}
  
  % hachures

  % petites cases, sans halo
  \begin{onlyenv}<1-2>
    \foreach \i in {0, 1, 2} {
      \foreach \j in {0, 1, 2} {
        \foreach \k in {1, 2, 3} {
          \draw (7*\i + \k, 7*\j) -- +(0, 4);
          \draw (7*\i, 7*\j + \k) -- +(4, 0);
        }
      }
    }
  \end{onlyenv}

  \begin{onlyenv}<3->
  % petites cases, halos compris
  \foreach \k in {1, 2, 3} {
    \draw (\k, 0) -- +(0, 5);
    \draw (0, \k) -- +(5, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (\k, 6) -- +(0, 6);
    \draw (0, 7 + \k) -- +(5, 0);
  }
  \foreach \k in {1, 2, 3, 4} {
    \draw (\k, 13) -- +(0, 5);
    \draw (0, 13 + \k) -- +(5, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (7 + \k, 0) -- +(0, 5);
    \draw (6, \k) -- +(6, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (7 + \k, 6) -- +(0, 6);
    \draw (6, 7 + \k) -- +(6, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (7 + \k, 13) -- +(0, 5);
    \draw (6, 14 + \k) -- +(6, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (14 + \k, 0) -- +(0, 5);
    \draw (13, \k) -- +(5, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (14 + \k, 6) -- +(0, 6);
    \draw (13, 7 + \k) -- +(5, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (14 + \k, 13) -- +(0, 5);
    \draw (13, 14 + \k) -- +(5, 0);
  }
\end{onlyenv}

% flèches des halos
  \begin{onlyenv}<2,5>
 \begin{scope}[xshift=0cm, yshift=14cm]
   \draw[red, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
   \draw[red, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \end{scope}
 \begin{scope}[xshift=7cm, yshift=14cm]
   \draw[orange, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
   \draw[orange, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
   \draw[orange, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \end{scope}
 \begin{scope}[xshift=14cm, yshift=14cm]
   \draw[yellow, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
   \draw[yellow, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \end{scope}

 \begin{scope}[xshift=0cm, yshift=7cm]
 \draw[green, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
 \draw[green, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \draw[green, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
 \begin{scope}[xshift=7cm, yshift=7cm]
 \draw[cyan, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
 \draw[cyan, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
 \draw[cyan, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \draw[cyan, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
  \begin{scope}[xshift=14cm, yshift=7cm]
 \draw[blue, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
 \draw[blue, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \draw[blue, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
 \begin{scope}[xshift=0cm, yshift=0cm]
 \draw[magenta, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
 \draw[magenta, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
 \begin{scope}[xshift=7cm, yshift=0cm]
 \draw[violet, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
 \draw[violet, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
 \draw[violet, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
  \begin{scope}[xshift=14cm, yshift=0cm]
 \draw[lightgray, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
 \draw[lightgray, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
\end{onlyenv}

\end{tikzpicture}%
\end{minipage}\begin{minipage}[T]{4.5cm}
  Each processor:
  \medskip
  \begin{itemize}
  \item<1-> Knows $T$ at time~$t$
  \item<2-> Sends/Receives the \alert{halo} from its neighbors
  \item<4-> Compute $T$ at time $t + \Delta t$
  \item<5-> Rinse, repeat
  \end{itemize}

  \medskip

  \begin{alertblock}<6>{Problem}
    Progress blocked by communications
  \end{alertblock}
\end{minipage}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{``Domain Decomposition'' (a.k.a. Data Parallelism)}

\begin{minipage}[T]{7.2cm}
\begin{tikzpicture}[scale=0.4]
  \path[use as bounding box] (1, 0) rectangle (18, 18);
  
  % halos
  \begin{onlyenv}<4->
  \filldraw[fill=violet]    (4, 0) rectangle  +(1,4);
  \filldraw[fill=magenta]   (6, 0) rectangle  +(1,4);
  \filldraw[fill=lightgray] (11, 0) rectangle  +(1,4);
  \filldraw[fill=violet]    (13, 0) rectangle  +(1,4);
  \filldraw[fill=cyan]    (4, 7) rectangle  +(1,4);
  \filldraw[fill=green]   (6, 7) rectangle  +(1,4);
  \filldraw[fill=blue] (11, 7) rectangle  +(1,4);
  \filldraw[fill=cyan]    (13, 7) rectangle  +(1,4);
  \filldraw[fill=orange]    (4, 14) rectangle  +(1,4);
  \filldraw[fill=red]   (6, 14) rectangle  +(1,4);
  \filldraw[fill=yellow]    (11,14) rectangle  +(1,4);
  \filldraw[fill=orange]    (13,14) rectangle  +(1,4);
  
  \filldraw[fill=blue]      (14, 4) rectangle  +(4,1);
  \filldraw[fill=cyan]      (7, 4) rectangle  +(4,1);
  \filldraw[fill=green]      (0, 4) rectangle  +(4,1);
  \filldraw[fill=lightgray]   (14, 6) rectangle  +(4,1);
  \filldraw[fill=violet]      (7, 6) rectangle  +(4,1);
  \filldraw[fill=magenta]     (0, 6) rectangle  +(4,1);  
  \filldraw[fill=blue]      (14, 13) rectangle  +(4,1);
  \filldraw[fill=cyan]      (7, 13) rectangle  +(4,1);
  \filldraw[fill=green]      (0, 13) rectangle  +(4,1);
  \filldraw[fill=yellow]      (14, 11) rectangle  +(4,1);
  \filldraw[fill=orange]      (7, 11) rectangle  +(4,1);
  \filldraw[fill=red]      (0, 11) rectangle  +(4,1);
\end{onlyenv}

  % gros carrés
    \filldraw[very thick, fill=red]       (0,  14) rectangle  +(4, 4);
    \filldraw[very thick, fill=orange]    (7,  14) rectangle  +(4,4);
    \filldraw[very thick, fill=yellow]    (14, 14) rectangle  +(4,4);
    \filldraw[very thick, fill=green]     (0,  7) rectangle  +(4,4);
    \filldraw[very thick, fill=cyan]      (7,  7) rectangle  +(4,4);
    \filldraw[very thick, fill=blue]      (14, 7) rectangle  +(4,4);
    \filldraw[very thick, fill=magenta]   (0,  0) rectangle  +(4,4);
    \filldraw[very thick, fill=violet]    (7,  0) rectangle  +(4,4);
    \filldraw[very thick, fill=lightgray] (14, 0) rectangle  +(4,4);
  
  \begin{onlyenv}<3-4>
    \draw[pattern=crosshatch, pattern color=black, very thick]    (1,  15) rectangle  +(2, 2);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (8,  15) rectangle +(2, 2);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (15, 15) rectangle +(2, 2);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (1,  8) rectangle  +(2, 2);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (8,  8) rectangle  +(2, 2);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (15, 8) rectangle  +(2, 2);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (1,  1) rectangle  +(2, 2);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (8,  1) rectangle  +(2, 2);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (15, 1) rectangle  +(2, 2);
  \end{onlyenv}

    \begin{onlyenv}<5->
    \draw[pattern=crosshatch, pattern color=black, very thick]       (0,  14) rectangle  +(4, 4);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (7,  14) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (14, 14) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]     (0,  7) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]      (7,  7) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]      (14, 7) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]   (0,  0) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick]    (7,  0) rectangle  +(4,4);
    \draw[pattern=crosshatch, pattern color=black, very thick] (14, 0) rectangle  +(4,4);
  \end{onlyenv}
  
  % hachures

  % petites cases, sans halo
  \begin{onlyenv}<1-3>
    \foreach \i in {0, 1, 2} {
      \foreach \j in {0, 1, 2} {
        \foreach \k in {1, 2, 3} {
          \draw (7*\i + \k, 7*\j) -- +(0, 4);
          \draw (7*\i, 7*\j + \k) -- +(4, 0);
        }
      }
    }
  \end{onlyenv}

  \begin{onlyenv}<4->
  % petites cases, halos compris
  \foreach \k in {1, 2, 3} {
    \draw (\k, 0) -- +(0, 5);
    \draw (0, \k) -- +(5, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (\k, 6) -- +(0, 6);
    \draw (0, 7 + \k) -- +(5, 0);
  }
  \foreach \k in {1, 2, 3, 4} {
    \draw (\k, 13) -- +(0, 5);
    \draw (0, 13 + \k) -- +(5, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (7 + \k, 0) -- +(0, 5);
    \draw (6, \k) -- +(6, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (7 + \k, 6) -- +(0, 6);
    \draw (6, 7 + \k) -- +(6, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (7 + \k, 13) -- +(0, 5);
    \draw (6, 14 + \k) -- +(6, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (14 + \k, 0) -- +(0, 5);
    \draw (13, \k) -- +(5, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (14 + \k, 6) -- +(0, 6);
    \draw (13, 7 + \k) -- +(5, 0);
  }
  \foreach \k in {1, 2, 3} {
    \draw (14 + \k, 13) -- +(0, 5);
    \draw (13, 14 + \k) -- +(5, 0);
  }
\end{onlyenv}

% flèches des halos
  \begin{onlyenv}<2-3,6>
 \begin{scope}[xshift=0cm, yshift=14cm]
   \draw[red, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
   \draw[red, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \end{scope}
 \begin{scope}[xshift=7cm, yshift=14cm]
   \draw[orange, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
   \draw[orange, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
   \draw[orange, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \end{scope}
 \begin{scope}[xshift=14cm, yshift=14cm]
   \draw[yellow, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
   \draw[yellow, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \end{scope}

 \begin{scope}[xshift=0cm, yshift=7cm]
 \draw[green, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
 \draw[green, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \draw[green, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
 \begin{scope}[xshift=7cm, yshift=7cm]
 \draw[cyan, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
 \draw[cyan, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
 \draw[cyan, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \draw[cyan, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
  \begin{scope}[xshift=14cm, yshift=7cm]
 \draw[blue, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
 \draw[blue, ultra thick, ->] (0, 0.5) to[bend right=20mm] +(0, -2.5);
 \draw[blue, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
 \begin{scope}[xshift=0cm, yshift=0cm]
 \draw[magenta, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
 \draw[magenta, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
 \begin{scope}[xshift=7cm, yshift=0cm]
 \draw[violet, ultra thick, ->] (3.5, 0) to[bend right=20mm] +(2.5, 0);
 \draw[violet, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
 \draw[violet, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
  \begin{scope}[xshift=14cm, yshift=0cm]
 \draw[lightgray, ultra thick, ->] (0.5, 4) to[bend right=20mm] +(-2.5, 0);
 \draw[lightgray, ultra thick, ->] (4, 3.5) to[bend right=20mm] +(0, 2.5);
\end{scope}
\end{onlyenv}

\end{tikzpicture}%
\end{minipage}\begin{minipage}[T]{4.5cm}
  Each processor:
  \medskip
  \begin{itemize}
  \item<1-> Knows $T$ at time~$t$
  \item<2-> Sends the \alert{halo} to its neighbors (\alert{Isend})
  \item<3-> Compute $T$ at time $t + \Delta t$ (\alert{interior})
  \item<4-> Waits end of comms
  \item<5-> Compute $T$ at time $t + \Delta t$ (\alert{border})
  \item<6-> Rinse, repeat
  \end{itemize}
\end{minipage}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile=singleslide]

\begin{wider}
\begin{minted}[fontsize=\footnotesize]{C}
int MPI_Sendrecv(void *sendbuf, int sendcount, MPI_Datatype sendtype, 
                 int dest, int sendtag, 
                 void *recvbuf, int recvcount, MPI_Datatype recvtype, 
                 int source, int recvtag, 
                 MPI_Comm comm, MPI_Status *status);
\end{minted}
\end{wider}

\begin{wider}
\begin{minted}[fontsize=\footnotesize]{C}
int MPI_Isend(void *buf, int count, MPI_Datatype datatype, 
              int dest, int tag, 
              MPI_Comm comm, MPI_Request *request);
int MPI_Irecv(void *buf, int count, MPI_Datatype datatype,
              int source, int tag, 
              MPI_Comm comm, MPI_Request *request);
int MPI_Waitall(int count, 
                MPI_Request requests[], MPI_Status statuses[]);
\end{minted}
\end{wider}

\begin{alertblock}{warning!}
  \begin{itemize}    
  \item East / West border: \alert{non-contiguous} data elements
    \item[$\Rightarrow$] Must create \alert{derived MPI types} (\mintinline{C}{MPI_Type_vector(...)})
  \end{itemize}
\end{alertblock}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iffalse
\section{Prefix-Sum}

\begin{frame}[fragile]
\frametitle{Parallélisme de données}


\begin{block}{Exemple classique : \emph{prefix-sum} (``scan'') (en place)}
\begin{minted}{C}
for (int i = 1; i < n; i++)
    A[i] = A[i] + A[i - 1];
\end{minted}
\end{block}

\bigskip

\begin{itemize}
\item \textbf{Dépendance de données}
\item Chaque itération a besoin du résultat de la précédente...
\item Changer l'algorithme   
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{\texttt{prefix-sum} : Cas de la mémoire partagée}


\begin{block}{Exemple classique : \emph{prefix-sum} (en place)}
\begin{minted}[fontsize=\small]{C}
double *B;

void prefix_sum(double * A, int n)
{
    if (n < 2)
        return;
    for (int i = 0; i < n / 2; i++)
        B[i] = A[2 * i] + A[2 * i + 1];
    prefix_sum(B, k);
    for (int i = 1; i < n; i += 2) {
          A[i] = B[i / 2];
          A[i + 1] = B[i / 2] + A[i + 1];
    }
}
\end{minted}
\end{block}


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Algorithme MIMD-DM pour \texttt{prefix-sum}}

\begin{tikzpicture}
  \filldraw[fill=red]    (0, 0) rectangle  +(1,1);
  \filldraw[fill=orange] (1, 0) rectangle  +(1,1);
  \filldraw[fill=yellow] (2, 0) rectangle  +(1,1);
  \filldraw[fill=green]  (3, 0) rectangle  +(1,1);
  \filldraw[fill=cyan]   (4, 0) rectangle  +(1,1);
  \filldraw[fill=blue]   (5, 0) rectangle  +(1,1);
  \filldraw[fill=magenta] (6, 0) rectangle  +(1,1);
  \filldraw[fill=violet] (7, 0) rectangle +(1,1);
  \filldraw[fill=lightgray] (8, 0) rectangle +(1,1);
  \filldraw[fill=darkgray] (9, 0) rectangle +(1,1);
  
  \draw[thick] (0, 0) rectangle (10, 1);
  \foreach \i in {0.2, 0.4, ..., 9.8}
  \draw (\i, 0) -- +(0, 1);
\end{tikzpicture}

\bigskip

\begin{enumerate}
\item $P_i$ calcule la somme $S_i$ de \emph{ses} données. \hfill \alert{[local]}
\item Ils font (collectivement) $T \gets \texttt{prefix-sum}(S)$.
  \begin{itemize}
  \item \texttt{MPI\_Scan}
  \end{itemize}
\item[$\rightarrow$] $P_i$ obtient $T_i = $ somme des données des $P_j$ (pour $j<i$).
\item $P_i$ \texttt{prefix-sum} ses données en ajoutant $T_i$. \hfill \alert{[local]}
\end{enumerate}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\begin{frame}
  \frametitle{Rappel : \texttt{reduce} par la méthode de l'arbre binomial}
  
  \begin{center}
    \begin{tikzpicture}[level distance=10mm, xscale=0.66, yscale=0.75]
  \foreach \i in {0,1,2,3,4} {
    \draw[semitransparent,gray] (-9, -4+\i) node[text=black,left] {t=\i} -- +(15, 0);
  }

  \node {15}
    child { node {7}
      child { node {3}
        child {node {1}
          child {node {0}}
        }
        child {node at (0, -1) {2}}
      }
      child[missing]
      child {node at (0,-1) {5}
        child {node {4}}
      }
      child {node at (0,-2) {6} }
    }
    child[missing]
    child[missing]
    child { node at (0, -1) {11}
      child {node {9}
        child {node {8} }
      }
      child {node at (0, -1) {10} }
    }
    child[missing]
    child { node at (0, -2) {13}
      child {node {12}}
    }
    child[missing]
    child { node at (0, -3) {14} }
;
\end{tikzpicture}
\end{center}


  \begin{center}
    \begin{tikzpicture}[level distance=10mm, xscale=0.66, yscale=0.75]

      %%%
      \path<1> [semitransparent,gray] (-9, -1) node[text=black,left] {t=0};
      \path<2> [semitransparent,gray] (-9, -1) node[text=black,left] {t=1};
      \path<3> [semitransparent,gray] (-9, -1) node[text=black,left] {t=2};
      \path<4> [semitransparent,gray] (-9, -1) node[text=black,left] {t=3};
      \path<5> [semitransparent,gray] (-9, -1) node[text=black,left] {t=4};
      
      \begin{scope}[every node/.style={font=\small\ttfamily}]
          \node<1> {[15]}
    child { node {[7]}
      child { node {[3]}
        child {node {[1]}
          child {node[text=red] {[0]}}
        }
        child {node at (0, -1) {[2]}}
      }
      child[missing]
      child {node at (0,-1) {[5]}
        child {node {[4]}}
      }
      child {node at (0,-2) {[6]} }
    }
    child[missing]
    child[missing]
    child { node at (0, -1) {[11]}
      child {node {[9]}
        child {node {[8]} }
      }
      child {node at (0, -1) {[10]} }
    }
    child[missing]
    child { node at (0, -2) {[13]}
      child {node {[12]}}
    }
    child[missing]
    child { node at (0, -3) {[14]} }
    ;
    
    %%%%%%

    \node<2> {[14:15]}
    child { node {[6:7]}
      child { node {[2:3]}
        child {node[text=red] {[0:1]}
          child {node[text=red] {[0]}}
        }
        child {node at (0, -1) {[2]}}
      }
      child[missing]
      child {node at (0,-1) {[4:5]}
        child {node {[4]}}
      }
      child {node at (0,-2) {[6]} }
    }
    child[missing]
    child[missing]
    child { node at (0, -1) {[10:11]}
      child {node {[8:9]}
        child {node {[8]} }
      }
      child {node at (0, -1) {[10]} }
    }
    child[missing]
    child { node at (0, -2) {[12:13]}
      child {node {[12]}}
    }
    child[missing]
    child { node at (0, -3) {[14]} }
    ;

    %%%%%% 

    \node<3> {[12:15]}
    child { node {[4:7]}
      child { node [text=red] {[0:3]}
        child {node[text=red] {[0:1]}
          child {node[text=red] {[0]}}
        }
        child {node at (0, -1) {[2]}}
      }
      child[missing]
      child {node at (0,-1) {[4:5]}
        child {node {[4]}}
      }
      child {node at (0,-2) {[6]} }
    }
    child[missing]
    child[missing]
    child { node at (0, -1) {[8:11]}
      child {node {[8:9]}
        child {node {[8]} }
      }
      child {node at (0, -1) {[10]} }
    }
    child[missing]
    child { node at (0, -2) {[12:13]}
      child {node {[12]}}
    }
    child[missing]
    child { node at (0, -3) {[14]} }
    ;

    %%%%%% 

    \node<4> {[8:15]}
    child { node[text=red] {[0:7]}
      child { node [text=red] {[0:3]}
        child {node[text=red] {[0:1]}
          child {node[text=red] {[0]}}
        }
        child {node at (0, -1) {[2]}}
      }
      child[missing]
      child {node at (0,-1) {[4:5]}
        child {node {[4]}}
      }
      child {node at (0,-2) {[6]} }
    }
    child[missing]
    child[missing]
    child { node at (0, -1) {[8:11]}
      child {node {[8:9]}
        child {node {[8]} }
      }
      child {node at (0, -1) {[10]} }
    }
    child[missing]
    child { node at (0, -2) {[12:13]}
      child {node {[12]}}
    }
    child[missing]
    child { node at (0, -3) {[14]} }
    ;

    %%%%%% 

    \node<5>[text=red] {[0:15]}
    child { node[text=red] {[0:7]}
      child { node [text=red] {[0:3]}
        child {node[text=red] {[0:1]}
          child {node[text=red] {[0]}}
        }
        child {node at (0, -1) {[2]}}
      }
      child[missing]
      child {node at (0,-1) {[4:5]}
        child {node {[4]}}
      }
      child {node at (0,-2) {[6]} }
    }
    child[missing]
    child[missing]
    child { node at (0, -1) {[8:11]}
      child {node {[8:9]}
        child {node {[8]} }
      }
      child {node at (0, -1) {[10]} }
    }
    child[missing]
    child { node at (0, -2) {[12:13]}
      child {node {[12]}}
    }
    child[missing]
    child { node at (0, -3) {[14]} }
    ;

  \end{scope}
\end{tikzpicture}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{\texttt{prefix-sum} en mémoire distribuée (arbre binomial)}

  \begin{exampleblock}{Phase 1 : \texttt{reduce}}
    Chaque noeud :
    \begin{enumerate}
    \item Récupère (et stocke) les valeurs de ses enfants.
    \item Calcule la somme, ajoute sa propre valeur, envoie à son père.
    \end{enumerate}
  \end{exampleblock}

  $\rightarrow \log_2$ messages successifs.
  
  \medskip

  \begin{alertblock}{Phase 2 : \texttt{prefix-sum}}
    Chaque noeud :
    \begin{enumerate}
    \item Reçoit une valeur de son père
      \begin{itemize}
      \item Somme des valeurs de ses frères \emph{gauches}.
        
      \end{itemize}
      
    \item Envoie à chacun de ses fils la somme des valeurs remontées par ses
      frères \emph{gauches}, plus la valeur reçue du père.
    \end{enumerate}
  \end{alertblock}

    $\rightarrow \log_2$ messages successifs.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}<5->
  \frametitle{\texttt{prefix-sum} par la méthode de l'arbre binomial}
  

  \begin{center}
    \begin{tikzpicture}[level distance=10mm, xscale=0.66, yscale=0.75]

      %%%
    \path<5> [semitransparent,gray] (-9, -1) node[text=black,left] {t=4};
    \path<6> [semitransparent,gray] (-9, -1) node[text=black,left] {t=5};
    \path<7> [semitransparent,gray] (-9, -1) node[text=black,left] {t=6};
    \path<8> [semitransparent,gray] (-9, -1) node[text=black,left] {t=7};
    
      \begin{scope}[every node/.style={font=\small\ttfamily}]

    \node<5>[text=red] {[0:15]}
    child { node[text=red] {[0:7]}
      child { node [text=red] {[0:3]}
        child {node[text=red] {[0:1]}
          child {node[text=red] {[0]}}
        }
        child {node at (0, -1) {[2]}}
      }
      child[missing]
      child {node at (0,-1) {[4:5]}
        child {node {[4]}}
      }
      child {node at (0,-2) {[6]} }
    }
    child[missing]
    child[missing]
    child { node at (0, -1) {[8:11]}
      child {node {[8:9]}
        child {node {[8]} }
      }
      child {node at (0, -1) {[10]} }
    }
    child[missing]
    child { node at (0, -2) {[12:13]}
      child {node {[12]}}
    }
    child[missing]
    child { node at (0, -3) {[14]} }
    ;


        \node<6>[text=red] {[0:15]}
    child { node[text=red] {[0:7]}
      child { node [text=red] {[0:3]}
        child {node[text=red] {[0:1]}
          child {node[text=red] {[0]}}
        }
        child {node[text=red] at (0, -1) {[0:2]}}
      }
      child[missing]
      child {node[text=red] at (0,-1) {[0:5]}
        child {node {[4]}}
      }
      child {node at (0,-2) {[6]} }
    }
    child[missing]
    child[missing]
    child { node[text=red] at (0, -1) {[0:11]}
      child {node {[8:9]}
        child {node {[8]} }
      }
      child {node at (0, -1) {[10]} }
    }
    child[missing]
    child { node at (0, -2) {[12:13]}
      child {node {[12]}}
    }
    child[missing]
    child { node at (0, -3) {[14]} }
    ;

    \node<7>[text=red] {[0:15]}
    child { node[text=red] {[0:7]}
      child { node [text=red] {[0:3]}
        child {node[text=red] {[0:1]}
          child {node[text=red] {[0]}}
        }
        child {node[text=red] at (0, -1) {[0:2]}}
      }
      child[missing]
      child {node[text=red] at (0,-1) {[0:5]}
        child {node[text=red] {[0:4]}}
      }
      child {node[text=red] at (0,-2) {[0:6]} }
    }
    child[missing]
    child[missing]
    child { node[text=red] at (0, -1) {[0:11]}
      child {node[text=red] {[0:9]}
        child {node {[8]} }
      }
      child {node at (0, -1) {[10]} }
    }
    child[missing]
    child { node[text=red] at (0, -2) {[0:13]}
      child {node {[12]}}
    }
    child[missing]
    child { node at (0, -3) {[14]} }
    ;

    \node<8>[text=red] {[0:15]}
    child { node[text=red] {[0:7]}
      child { node [text=red] {[0:3]}
        child {node[text=red] {[0:1]}
          child {node[text=red] {[0]}}
        }
        child {node[text=red] at (0, -1) {[0:2]}}
      }
      child[missing]
      child {node[text=red] at (0,-1) {[0:5]}
        child {node[text=red] {[0:4]}}
      }
      child {node[text=red] at (0,-2) {[0:6]} }
    }
    child[missing]
    child[missing]
    child { node[text=red] at (0, -1) {[0:11]}
      child {node[text=red] {[0:9]}
        child {node[text=red] {[0:8]} }
      }
      child {node[text=red] at (0, -1) {[0:10]} }
    }
    child[missing]
    child { node[text=red] at (0, -2) {[0:13]}
      child {node[text=red] {[0:12]}}
    }
    child[missing]
    child { node[text=red] at (0, -3) {[0:14]} }
    ;

  \end{scope}
\end{tikzpicture}
\end{center}
\end{frame}
\fi

\section{Linear Algebra}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \centering
  \vfill
  \Huge Linear Algebra
  \vfill
\end{frame}

\begin{frame}
  \frametitle{Importance of Linear Algebra}

  \begin{alertblock}{Reason}
  Systems of \textbf{linear} equations are the only ones we can solve
    \begin{itemize}
    \item (efficiently, at least)
    \end{itemize}
  \end{alertblock}

  \begin{itemize}
  \item $Ax = b$
  \item $AX = B$  \hfill (multiple right-hand sides)
  \item $\min_x \| Ax - b \|_2$ \hfill (overdetermined linear least squares)
  \item $\min_x \| x \|_2$ s.t. $Ax = b$ \hfill (underdetermined linear least squares)
  \item $Av = \lambda v$ \hfill (eigenvalues/eigenvectors)

  \end{itemize}

  \medskip

  \begin{center}
    \fbox{Basic building block of nearly all scientific computation}
  \end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Dense}

\begin{frame}
  \frametitle{BLAS}

  % how to write fast software?
  % use the right tools
  % small set of vesratile and optimized libraries
  
  \begin{block}{Basic Linear Algebra Subroutines}
    \begin{itemize}
    \item Software libraries developped in the 1980's (Fortran-77...)
    \item \red{Simple} and \red{common} operations
    \item \red{heavily optimized}
      \begin{itemize}
      \item[$\Rightarrow$] you willl never do better
      \end{itemize}
    \end{itemize}
  \end{block}

  \begin{exampleblock}{Common HPC Design Strategy}
    \begin{itemize}
    \item More complex linear algebra use the BLAS
    \item Simplifies development
      \begin{itemize}
      \item Just need to remember the interface
      \end{itemize}
    \item High-speed BLAS $\leadsto$ high-speed software
    \item Ugly low-level optimizations \emph{confined} inside the BLAS
    \end{itemize}
  \end{exampleblock}  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{BLAS Levels}

  \[
    \texttt{x} \in \{ \texttt{S}, \texttt{D}, \texttt{C}, \texttt{Z} \}
  \]
  
  \begin{block}{Level 1 Routines: \red{vector} operations}
    \begin{itemize}
    \item \texttt{xSCAL} : $x \gets \alpha x$
    \item \texttt{xCOPY} : $x \gets y$
    \item \texttt{xAXPY} : $y \gets \alpha x + y$
    \item \texttt{xDOT} : $\alpha \gets x \cdot y$
    \item \texttt{xNORM} : $\alpha \gets \| x \|_2$
    \item \texttt{xSUM} : $k \gets \sum_i | x_i |$
    \item \texttt{IxAMAX} : $k \gets \argmax_i | x_i |$
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{BLAS Levels}

  \[
    \texttt{x} \in \{ \texttt{S}, \texttt{D}, \texttt{C}, \texttt{Z} \}
  \]
  
  \begin{block}{Level 2 Routines: \red{matrix-vector} operations}
    \begin{itemize}
    \item Matrix-vector product (\texttt{xGEMV}) 
      \begin{itemize}
      \item $y \gets \alpha Ax + \beta y$
      \item Options to multiply by $A^t$ or $A^h$
      \item Special cases: symmetric $A$ (\texttt{xSYMV}), triangular $A$ (\texttt{xTRMV})
      \end{itemize}

      \medskip
      
    \item Triangular solve (\texttt{xTRSV})
      \begin{itemize}
      \item Solve $Lx = b$ or $Ux = b$
      \end{itemize}

      \medskip
      
    \item Rank-1 update (\texttt{xGER})
      \begin{itemize}
      \item $A \gets A + \alpha x y^t$        
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{BLAS Levels}

  \[
    \texttt{x} \in \{ \texttt{S}, \texttt{D}, \texttt{C}, \texttt{Z} \}
  \]
  
  \begin{block}{Level 3 Routines: \red{matrix-matrix} operations}
    \begin{itemize}
    \item Matrix-Matrix product (\texttt{xGEMM}) 
      \begin{itemize}
      \item $C \gets \alpha AB + \beta C$
      \item Options to use $A^t$ or $B^t$
      \item Special cases: symmetric $A,B$ (\texttt{xSYMM}), triangular $A$ (\texttt{xTRMM})
      \end{itemize}

      \medskip
      
    \item Triangular solve (\texttt{xTRSM}) with multiple right-hand sides
      \begin{itemize}
      \item Solve $LX = B$ or $UX = B$
      \end{itemize}

      \medskip
      
    \item Rank-$k$ symmetric update (\texttt{xSYRK})
      \begin{itemize}
      \item $C \gets \alpha AA^t + \beta C$ 
      \item Symmetric $C$
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[label=blasdata]
  \frametitle{Data Representation}

  \begin{alertblock}{Matrices represented as \textbf{\alert{1D arrays}}}
    \begin{itemize}
    \item \textbf{Never ever} as array of pointers to arrays
    \end{itemize}
  \end{alertblock}

  \begin{block}{Two possible orderings}
    \begin{itemize}
    \item In memory: \texttt{[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b]}
    \item Row-major order (C)
      \[
        \begin{pmatrix}
          0 & 1 & 2 & 3 \\
          4 & 5 & 6 & 7 \\
          8 & 9 & a & b
        \end{pmatrix}
      \]
      
    \item Column-major order (Fortran)
      \[
        \begin{pmatrix}
          0 & 3 & 6 & 9 \\
          1 & 4 & 7 & a \\
          2 & 5 & 8 & b
        \end{pmatrix}
      \]
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[label=blasdata,fragile]
  \frametitle{Data Representation (continued)}

  \begin{exampleblock}{Matrix given by}
    \begin{itemize}
    \item Memory address of first coefficient
    \item \#Rows ($m$)
    \item \#Columns ($n$)
    \item Leading dimension (``stride'')
      \begin{itemize}
      \item Sub-matrices for free
      \end{itemize}
    \end{itemize}
  \end{exampleblock}

  \begin{columns}
    \begin{column}{5.33cm}
      \begin{tikzpicture}[scale=0.66]
%        \draw[red,dotted,use as bounding box] (0, 0) rectangle (5, 5);
        \tikzmat{0,0}{8,5}
        \filldraw[fill=Gray!70] (0, 0) rectangle (8,5);
        \filldraw<2->[fill=blue] (4, 1) rectangle +(2,2.5);
        \foreach \i in {0.5, 1, ..., 4.5} {
          \draw (0, \i) -- +(8, 0);
        }
        \foreach \i in {0.5, 1, ..., 7.5} {
          \draw (\i, 0) -- +(0, 5);
        }
      \end{tikzpicture}
    \end{column}
    \begin{column}{6.66cm}
      \begin{itemize}
      \item Row-major (\mintinline{C}{ld >= n})
        \begin{itemize}
        \item $M_{ij} \leadsto \texttt{A[i*ld + j]}$
        \item {\color{Gray} $A, m = 10$, $n = 16$, $ld = 16$}
        \item<2-> {\color{blue} $A + 57, m = 5$, $n = 4$, $ld = 16$}
        \end{itemize}
      \item Column-major (\mintinline{C}{ld >= m})      
        \begin{itemize}
        \item $M_{ij} \leadsto \texttt{A[j*ld + i]}$
        \item {\color{Gray} $A, m = 10$, $n = 16$, $ld = 10$}
        \item<2-> {\color{blue} $A + 84, m = 5$, $n = 4$, $ld = 10$}
        \end{itemize}
      \end{itemize}  
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[label=blasdata]
  \frametitle{Data Representation (continued)}

  \begin{exampleblock}{Vector given by}
    \begin{itemize}
    \item Memory address of first coefficient
    \item Size ($n$)
    \item Increment (``stride'')
    \end{itemize}
  \end{exampleblock}

  \begin{columns}
    \begin{column}{5.33cm}
      \begin{tikzpicture}[scale=0.66]
        \tikzmat{0,0}{8,5}
        \filldraw[fill=Gray!70] (0, 0) rectangle (8,5);
        \filldraw<2->[fill=orange] (0, 0.5) rectangle +(8,0.5);
        \filldraw<3->[fill=blue] (3, 1) rectangle +(0.5, 4);
        \foreach \i in {0, 0.5, ..., 4.5} {
          \filldraw<4->[fill=violet] (\i, 4.5-\i) rectangle +(0.5, 0.5);
        }
        \foreach \i in {1, 1.5, ..., 3.5} {
          \filldraw<5->[fill=green] (\i + 4, \i) rectangle +(0.5, 0.5);
        }
        \foreach \i in {0.5, 1, ..., 4.5} {
          \draw (0, \i) -- +(8, 0);
        }
        \foreach \i in {0.5, 1, ..., 7.5} {
          \draw (\i, 0) -- +(0, 5);
        }
      \end{tikzpicture}

    \end{column}
    \begin{column}{6.66cm}

      \begin{itemize}
      \item Row-major ($M_{ij} \leadsto \texttt{A[i*ld + j]}$)
        \begin{itemize}
        \item<2-> {\color{orange} $A + 128, n=16$, $i = 1$}
        \item<3-> {\color{blue} $A + 6, n = 8$, $i = 16$}
        \item<4-> {\color{violet} $A, n = 10$, $i = 17$}
        \item<5-> $A + 31, n = 6$, $i = 15$

        \end{itemize}
      \end{itemize}  
    \end{column}
  \end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Solving Actual Problems}

  \begin{center}
    \begin{tikzpicture}[yscale=0.5,xscale=0.66,every node/.style={anchor=south east,font=\bfseries}]
      \node[red] at (0, 5) {L};
      \node[red] at (0, 4) {L};
      \node[blue] at (0, 3) {L};
      \node[blue] at (0, 1) {L};
      \node[blue] at (0, 0) {L};
      \node[blue] at (0, 2) {L};
      
      \node[red] at (1, 5) {A};
      \node[red] at (1, 4) {-A};
      \node[blue]  at (1, 3) {A};
      \node[blue]  at (1, 2) {-A};
      \node[blue] at (1, 1) {A};
      \node[blue] at (1, 0) {-A};

      \node[blue]  at (2, 5) {P};
      \node[blue]  at (2, 4) {P};
      \node[red] at (2, 3) {P};
      \node[red] at (2, 2) {P};
      \node[blue] at (2, 1) {-P};
      \node[blue] at (2, 0) {-P};

      \node[blue]  at (3, 5) {A};
      \node[blue]  at (3, 4) {-A};
      \node[red] at (3, 3) {A};
      \node[red] at (3, 2) {-A};
      \node[blue] at (3, 1) {A};
      \node[blue] at (3, 0) {-A};

      \node[blue] at (4, 5) {C};
      \node[blue] at (4, 4) {C};
      \node[blue] at (4, 3) {-C};
      \node[blue]  at (4, 2) {-C};
      \node[red]  at (4, 1) {C};
      \node[red] at (4, 0) {C};

      \node[blue] at (5, 5) {K};
      \node[blue] at (5, 4) {-K};
      \node[blue] at (5, 3) {-K};
      \node[blue]  at (5, 2) {K};
      \node[red]  at (5, 1) {K};
      \node[red] at (5, 0) {-K};

    \end{tikzpicture}
  \end{center}
  
  \begin{exampleblock}{\textbf{LAPACK}: Linear Algebra PACKage}
    \begin{itemize}
    \item Development started in the 1990's (still active)
    \item Built upon the BLAS (Fortran: \alert{column-major})
    \item Solve linear systems, least-squares, eigenvalues, etc.
    \item \textbf{Main algorithmic idea}: \red{use level-3 BLAS}
      \begin{itemize}
      \item High \red{arithmetic intensity}
      \item Significant performance gain over naive code
      \end{itemize}
    \end{itemize}
  \end{exampleblock}  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{frame}
  \frametitle{LU Factorization}

  \begin{center}
    \begin{tikzpicture}
      \useasboundingbox (-0.5,-0.3) rectangle (8.25,2.5);
      
      % L en haut
      \begin{scope}[xshift=3cm]
        \tikzmat{0,0}{2.2,2.2}
        \foreach \i in {0, 0.2, ..., 2}
        \path (\i,2-\i) rectangle node {\scalebox{0.55}{1}} +(0.2,0.2);
        \filldraw[fill=cyan] (0,0) -- ++(0, 2)  -- ++(2,-2) -- cycle;
        \node at (0.5, 0.5) {L};
      \end{scope}
      
      % U en haut
      \begin{scope}[xshift=5.5cm]
        \tikzmat{0,0}{2.2,2.2}
        \draw[fill=LimeGreen] (0,2.2) -- ++(2.2,0) -- ++(0,-2.2) -- cycle;
        \node at (1.5, 1.5) {U};
      \end{scope}
      
      \node at (2.6,1) {$=$};
    
      % matrice grise en haut
      \begin{scope}[xshift=0cm]
        \tikzmat{0,0}{2.2,2.2}
        \filldraw[fill=Gray!70] (0,0) rectangle node{A} +(2.2,2.2);
      \end{scope}
    \end{tikzpicture}
  \end{center}

  \bigskip
  
  Main tool to solve $Ax = b$ when $A$ is invertible

\end{frame}

%%%%

\begin{frame}[label=lu]
  \frametitle{LU Factorization}
%  \framesubtitle{Right-looking Algorithm}

  \begin{columns}
    \begin{column}{5cm}
      \begin{tikzpicture}
        \draw[red,dotted,use as bounding box] (0, 0) rectangle (5, 5);
    \tikzmat{0,0}{5,5}
    \filldraw[fill=Gray!70] (0, 0) rectangle (5,5);

    \node<1> at (2.5, 2.5) {$A$};

    \node<2> at (1.25, 3.75) {$A_{00}$};
    \node<2> at (1.25, 1.25) {$A_{10}$};

    \node<2-6> at (3.75, 1.25) (a11) {$A_{11}$};
    \node<8> at (3.75, 1.25) (b) {$A_{11} - L_{10} U_{01}$};

    \node<2-4> at (3.75, 3.75) {$A_{01}$};

    \draw<3>[pattern=north west lines] (0,0) rectangle +(2.5, 5);
    \draw<5>[pattern=north west lines] (2.5, 2.5) rectangle +(2.5, 2.5);
    \draw<7,9>[pattern=north west lines] (2.5 , 0) rectangle +(2.5, 2.5);
    
    \filldraw<4->[fill=cyan] (0,5) -- ++(2.5, -2.5) -- (2.5, 0) -- (0, 0) -- cycle;
    \filldraw<4-5>[fill=LimeGreen] (0,5) -- (2.5, 2.5) -- (2.5, 5) -- cycle;
    \filldraw<6->[fill=LimeGreen] (0,5) -- ++(5, 0) -- (5, 2.5) -- (2.5, 2.5) -- cycle;
    
    \node<4-> at (1.25, 1.25) (l10) {$L_{10}$};
    \node<4-> at (0.75, 3.25) (l00) {$L_{00}$};
    \node<4-> at (1.75, 4.25) {$U_{00}$};
    \node<6-> at (3.75, 3.75) (u01) {$U_{01}$};

    \draw<5>[red,ultra thick, ->] (l00) edge (3.4, 3.75);    
    \draw<7>[red,ultra thick, ->] (u01) edge (a11);    
    \draw<7>[red,ultra thick, ->] (l10) edge (a11);    

    
    \filldraw<10>[fill=cyan] (2.5, 2.5) -- (5, 0) -- (2.5, 0) -- cycle;
    \filldraw<10>[fill=LimeGreen] (2.5, 2.5) -- (5, 2.5) -- (5, 0) -- cycle;
    \node<10> at (3.25, 0.75) {$L_{11}$};
    \node<10> at (4.25, 1.75) {$U_{11}$};


      \draw<2->[red, ultra thick, dashed] (-0.2, 2.5) -- (5.2, 2.5);
      \draw<2->[red, ultra thick, dashed] (2.5, -0.2) -- (2.5, 5.2);
  \end{tikzpicture}
\end{column}
\begin{column}{5.5cm}

 \begin{block}{Recursive algorithm}
   \begin{enumerate}
   \item<3-> Factorize left half
   \item<5-> Solve $L_{00} U_{01} = A_{01}$
     \begin{itemize}
     \item level-3 \texttt{TRSM}
     \end{itemize}
     
   \item<7-> $A_{11} \gets A_{11} - L_{10} U_{01}$
     \begin{itemize}
     \item level-3 \texttt{GEMM}
     \end{itemize}
   \item<9-> Factorize $A_{11} - L_{10} U_{01}$
     
   \end{enumerate}
 \end{block}

\end{column}
\end{columns}

\medskip

\[
  \begin{pmatrix}
       A_{00} & A_{01} \\
       A_{10} & A_{11} 
     \end{pmatrix}
     =
     \begin{pmatrix}
       L_{00} &  \\
       L_{10} & L_{11} 
     \end{pmatrix}
     \begin{pmatrix}
       U_{00} & U_{01} \\
       & U_{11} 
     \end{pmatrix}
   \]

   \vspace{-0.5cm}
   
   \begin{align*}     
     L_{00} U_{01} &= A_{01} \\
     L_{11} U_{11} &= A_{11} - L_{10} U_{01}
   \end{align*}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[label=trsm]
  \frametitle{Level-3 Triangular Solve}

  \begin{center}
      \begin{tikzpicture}[scale=0.8]
        \useasboundingbox (-5.3, 0.4) rectangle (5, 4.8);

        \begin{scope}[xshift=-5.3cm]
          \tikzmat{0,0}{5,5}
          \filldraw[fill=cyan] (0, 0) -- (0, 5) -- (5, 0) -- cycle;
          \node<1> at (1.25, 1.25) {$L$};

          \node<2-> at (1.25, 1.25) (l10) {$L_{10}$};
          \node<2-> at (0.75, 3.25) (l00) {$L_{00}$};
          \node<2-> at (3.25, 0.75)  (l11) {$L_{11}$};
          
          % découpage rouge
          \draw<2->[red, ultra thick, dashed] (-0.2, 2.5) -- (5.2, 2.5);
          \draw<2->[red, ultra thick, dashed] (2.5, -0.2) -- (2.5, 5.2);
        \end{scope}

        
        \tikzmat{0,0}{5,5}
        \filldraw[fill=Gray!70] (0, 0) rectangle (5,5);

        \node<1> at (2.5, 2.5) {$B$};
        
%        \coordinate (b0) at (2.5, 3.75) ;
        \node<2> at (2.5, 3.75) (b0) {$B_{0}$};
        
%        \node (b1) at (2.5, 1.25) {};
        \node<2-4> at (2.5, 1.25)  (b1) {$B_{1}$};
        \node<6> at (2.5, 1.25) (b) {$B_{1} - L_{10} X_{0}$};
        
        \draw<3>[pattern=north west lines] (0, 2.5) rectangle +(5, 2.5);
        \draw<5>[pattern=north west lines] (0, 0) rectangle +(5, 2.5);
        \draw<7>[pattern=north west lines] (0, 0) rectangle +(5, 2.5);
        
        \filldraw<4->[fill=yellow] (0, 2.5) rectangle +(5, 2.5);
        \filldraw<8->[fill=yellow] (0, 0) rectangle +(5, 2.5);

        \node<4-> at (2.5, 3.75) (x0) {$X_{0}$};
        \node<8-> at (2.5, 1.25) (x1) {$X_{1}$};
                
        % découpage rouge
        \draw<2->[red, ultra thick, dashed] (-0.2, 2.5) -- (5.2, 2.5);

        % 1er appel récursif
        \draw<3>[red,ultra thick, ->] (l00) edge (b0);    

        % GEMM
        \draw<5>[red,ultra thick, ->] (x0) edge (b1);    
        \draw<5>[red,ultra thick, ->] (l10) edge (b1);

        % 2ème appel récursif
        \draw<7>[red,ultra thick, ->] (l11) edge (b1);    
      \end{tikzpicture}
    \end{center}
    
  \begin{columns}
    \begin{column}{5cm}
\[
     \begin{pmatrix}
       L_{00} &  \\
       L_{10} & L_{11} 
     \end{pmatrix}
     \begin{pmatrix}
       X_{0} \\
       X_{1}  
     \end{pmatrix}
     =
     \begin{pmatrix}
     B_{0} \\
     B_{1} \\
   \end{pmatrix}
 \]

   \vspace{-0.5cm}
   
   \begin{align*}     
     L_{00} X_{0} &= B_{0} \\
     L_{11} X_1 &= B_{1} - L_{10} X_{0}
   \end{align*}
      
    \end{column}
    \begin{column}{5.5cm}

 \begin{block}{Recursive algorithm}
   \begin{enumerate}
   \item<3-> Solve $L_{00} X_{0} = B_{0}$
     \begin{itemize}
     \item level-3 \texttt{TRSM}
     \end{itemize}

   \item<5-> $B_{1} \gets B_{1} - L_{10} X_{0}$
     \begin{itemize}
     \item level-3 \texttt{GEMM}
     \end{itemize}
     
   \item<7-> Solve $L_{11} X_1 = B_{1} - L_{10} X_{0}$
     \begin{itemize}
     \item level-3 \texttt{TRSM}
     \end{itemize}
   \end{enumerate}
 \end{block}

\end{column}
\end{columns}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Distributed LU Factorization}

  \begin{columns}
    \begin{column}{5cm}
  \begin{tikzpicture}
    \path[red,dotted,use as bounding box] (0, 0) rectangle (5, 5);
    \tikzmat{0,0}{5,5}
    \filldraw[fill=Gray!70] (0, 0) rectangle (5,5);

    % 2nd column gets ready
    \draw<7->[pattern=north west lines] (1, 3) rectangle +(1, 1);
    \draw<9->[pattern=north west lines] (1, 2) rectangle +(1, 1);
    \draw<9->[pattern=north west lines] (2, 3) rectangle +(1, 1);

    \draw<9->[pattern=north west lines] (2, 3) rectangle +(1, 1);
    \draw<11->[pattern=north west lines] (1, 1) rectangle +(1, 1);
    \draw<11->[pattern=north west lines] (2, 2) rectangle +(1, 1);
    \draw<11->[pattern=north west lines] (3, 3) rectangle +(1, 1);
    \draw<11->[pattern=north west lines] (3, 3) rectangle +(1, 1);

    \draw<13->[pattern=north west lines] (4, 3) rectangle +(1, 1);
    \draw<13->[pattern=north west lines] (3, 2) rectangle +(1, 1);
    \draw<13->[pattern=north west lines] (2, 1) rectangle +(1, 1);
    \draw<13->[pattern=north west lines] (1, 0) rectangle +(1, 1);

    \draw<15->[pattern=north west lines] (2, 0) rectangle +(1, 1);
    \draw<15->[pattern=north west lines] (3, 1) rectangle +(1, 1);
    \draw<15->[pattern=north west lines] (4, 2) rectangle +(1, 1);

    \draw<17->[pattern=north west lines] (3, 0) rectangle +(1, 1);
    \draw<17->[pattern=north west lines] (4, 1) rectangle +(1, 1);

    \draw<19->[pattern=north west lines] (4, 0) rectangle +(1, 1);

    % 2nd wave
    \draw<19->[pattern=north east lines] (2, 2) rectangle +(1, 1);

    \draw<21->[pattern=north east lines] (3, 2) rectangle +(1, 1);
    \draw<21->[pattern=north east lines] (2, 1) rectangle +(1, 1);

    \draw<23->[pattern=north east lines] (2, 0) rectangle +(1, 1);
    \draw<23->[pattern=north east lines] (3, 1) rectangle +(1, 1);
    \draw<23->[pattern=north east lines] (4, 2) rectangle +(1, 1);

    \draw<25->[pattern=north east lines] (3, 0) rectangle +(1, 1);
    \draw<25->[pattern=north east lines] (4, 1) rectangle +(1, 1);
    
    \draw<27->[pattern=north east lines] (4, 0) rectangle +(1, 1);

    % 3rd wave
    \filldraw<29->[fill=Gray!70]  (3, 1) rectangle +(1, 1);
    \draw<29->[pattern=fivepointed stars]  (3, 1) rectangle +(1, 1);

    \filldraw<31->[fill=Gray!70]  (3, 0) rectangle +(1, 1);
    \draw<31->[pattern=fivepointed stars]  (3, 0) rectangle +(1, 1);

    \filldraw<31->[fill=Gray!70]  (4, 1) rectangle +(1, 1);
    \draw<31->[pattern=fivepointed stars]  (4, 1) rectangle +(1, 1);

    \filldraw<33->[fill=Gray!70]  (4, 0) rectangle +(1, 1);
    \draw<33->[pattern=fivepointed stars]  (4, 0) rectangle +(1, 1);
    
    \filldraw<3->[fill=cyan] (0,5) -- (0, 0) -- (1, 0) -- (1, 4) -- cycle;
    \filldraw<3->[fill=LimeGreen] (0,5) -- ++(1, 0) -- ++(0, -1) -- cycle;
    
    % 4rd wave
    \filldraw<37->[fill=Gray!70]  (4, 0) rectangle +(1, 1);
    \draw<37->[pattern=bricks]  (4, 0) rectangle +(1, 1);


    % U_01
    \filldraw<5->[fill=LimeGreen] (1,5) rectangle ++(1, -1);
    \filldraw<7->[fill=LimeGreen] (2,5) rectangle ++(1, -1);
    \filldraw<9->[fill=LimeGreen] (3,5) rectangle ++(1, -1);
    \filldraw<11->[fill=LimeGreen] (4,5) rectangle ++(1, -1);

        % U_11
    \filldraw<17->[fill=LimeGreen] (2,4) rectangle ++(1, -1);
    \filldraw<19->[fill=LimeGreen] (3,4) rectangle ++(1, -1);
    \filldraw<21->[fill=LimeGreen] (4,4) rectangle ++(1, -1);

    % U_22
    \filldraw<27->[fill=LimeGreen] (3,3) rectangle ++(1, -1);
    \filldraw<29->[fill=LimeGreen] (4,3) rectangle ++(1, -1);

    % U_33
    \filldraw<35->[fill=LimeGreen] (4,2) rectangle ++(1, -1);

    \filldraw<39>[fill=cyan] (4,1) -- (5, 0) -- (4, 0) -- cycle;
    \filldraw<39>[fill=LimeGreen] (4,1) -- ++(1, 0) -- ++(0, -1) -- cycle;
        
    % Attack 2nd col
    \filldraw<15->[fill=cyan] (1,4) -- (1, 0) -- (2, 0) -- (2, 3) -- cycle;
    \filldraw<15->[fill=LimeGreen] (1,4) -- ++(1, 0) -- ++(0, -1) -- cycle;

    % Attack 3rd col
    \filldraw<25->[fill=cyan] (2,3) -- (2, 0) -- (3, 0) -- (3, 2) -- cycle;
    \filldraw<25->[fill=LimeGreen] (2,3) -- ++(1, 0) -- ++(0, -1) -- cycle;

    % Attack 4th col
    \filldraw<33->[fill=cyan] (3,2) -- (3, 0) -- (4, 0) -- (4, 1) -- cycle;
    \filldraw<33->[fill=LimeGreen] (3,2) -- ++(1, 0) -- ++(0, -1) -- cycle;

    
    % grid
    \foreach \i in {1,2,3,4}  {
      \draw[] (\i, 0) -- (\i, 5);
      \draw[] (0, \i) -- (5, \i);
    }

    % L00 propagates to the right
    \draw<4>[red,->,very thick] (0.15, 4.66) -- ++(1.25, 0);
    \draw<6>[red,->,very thick] (0.15, 4.66) -- ++(2.25, 0);
    \draw<8>[red,->,very thick] (0.15, 4.66) -- ++(3.25, 0);
    \draw<10>[red,->,very thick] (0.15, 4.66) -- ++(4.25, 0);

    % L11 propagates to the right
    \draw<16>[red,->,very thick] (1.15, 3.66) -- ++(1.25, 0);
    \draw<18>[red,->,very thick] (1.15, 3.66) -- ++(2.25, 0);
    \draw<20>[red,->,very thick] (1.15, 3.66) -- ++(3.25, 0);
    
    % L22 propagates to the right
    \draw<26>[red,->,very thick] (2.15, 2.66) -- ++(1.25, 0);
    \draw<28>[red,->,very thick] (2.15, 2.66) -- ++(2.25, 0);

    % L33 propagates to the right
    \draw<34>[red,->,very thick] (3.15, 1.66) -- ++(1.25, 0);
    

    
    % first row of U goes down
    \draw<6>[red,->,very thick] (1.5, 4.25) -- ++(0, -0.5);
    \draw<8>[red,->,very thick] (1.5, 4.25) -- ++(0, -1.5);
    \draw<10>[red,->,very thick] (1.5, 4.25) -- ++(0, -2.5);
    \draw<12>[red,->,very thick] (1.5, 4.25) -- ++(0, -3.5);

    \draw<8>[red,->,very thick] (2.5, 4.25) -- ++(0, -0.5);
    \draw<10>[red,->,very thick] (2.5, 4.25) -- ++(0, -1.5);
    \draw<12>[red,->,very thick] (2.5, 4.25) -- ++(0, -2.5);
    \draw<14>[red,->,very thick] (2.5, 4.25) -- ++(0, -3.5);

    \draw<10>[red,->,very thick] (3.5, 4.25) -- ++(0, -0.5);
    \draw<12>[red,->,very thick] (3.5, 4.25) -- ++(0, -1.5);
    \draw<14>[red,->,very thick] (3.5, 4.25) -- ++(0, -2.5);
    \draw<16>[red,->,very thick] (3.5, 4.25) -- ++(0, -3.5);

    \draw<12>[red,->,very thick] (4.5, 4.25) -- ++(0, -0.5);
    \draw<14>[red,->,very thick] (4.5, 4.25) -- ++(0, -1.5);
    \draw<16>[red,->,very thick] (4.5, 4.25) -- ++(0, -2.5);
    \draw<18>[red,->,very thick] (4.5, 4.25) -- ++(0, -3.5);

    % L_01 goes right
    \draw<6>[red,->,very thick] (0.75, 3.5) -- ++(0.5, 0);
    \draw<8>[red,->,very thick] (0.75, 3.5) -- ++(1.5, 0);
    \draw<10>[red,->,very thick] (0.75, 3.5) -- ++(2.5, 0);
    \draw<12>[red,->,very thick] (0.75, 3.5) -- ++(3.5, 0);
    
    \draw<8>[red,->,very thick] (0.75, 2.5) -- ++(0.5, 0);
    \draw<10>[red,->,very thick] (0.75, 2.5) -- ++(1.5, 0);
    \draw<12>[red,->,very thick] (0.75, 2.5) -- ++(2.5, 0);
    \draw<14>[red,->,very thick] (0.75, 2.5) -- ++(3.5, 0);

    \draw<10>[red,->,very thick] (0.75, 1.5) -- ++(0.5, 0);
    \draw<12>[red,->,very thick] (0.75, 1.5) -- ++(1.5, 0);
    \draw<14>[red,->,very thick] (0.75, 1.5) -- ++(2.5, 0);
    \draw<16>[red,->,very thick] (0.75, 1.5) -- ++(3.5, 0);

    \draw<12>[red,->,very thick] (0.75, 0.5) -- ++(0.5, 0);
    \draw<14>[red,->,very thick] (0.75, 0.5) -- ++(1.5, 0);
    \draw<16>[red,->,very thick] (0.75, 0.5) -- ++(2.5, 0);
    \draw<18>[red,->,very thick] (0.75, 0.5) -- ++(3.5, 0);

    % L_11 goes right
    \draw<18>[red,->,very thick] (1.75, 2.5) -- ++(0.5, 0);
    \draw<20>[red,->,very thick] (1.75, 2.5) -- ++(1.5, 0);
    \draw<22>[red,->,very thick] (1.75, 2.5) -- ++(2.5, 0);

    \draw<20>[red,->,very thick] (1.75, 1.5) -- ++(0.5, 0);
    \draw<22>[red,->,very thick] (1.75, 1.5) -- ++(1.5, 0);
    \draw<24>[red,->,very thick] (1.75, 1.5) -- ++(2.5, 0);

    \draw<22>[red,->,very thick] (1.75, 0.5) -- ++(0.5, 0);
    \draw<24>[red,->,very thick] (1.75, 0.5) -- ++(1.5, 0);
    \draw<26>[red,->,very thick] (1.75, 0.5) -- ++(2.5, 0);

    % L_22 goes right
    \draw<28>[red,->,very thick] (2.75, 1.5) -- ++(0.5, 0);
    \draw<30>[red,->,very thick] (2.75, 1.5) -- ++(1.5, 0);

    \draw<30>[red,->,very thick] (2.75, 0.5) -- ++(0.5, 0);
    \draw<32>[red,->,very thick] (2.75, 0.5) -- ++(1.5, 0);

    % L_33 goes right
    \draw<36>[red,->,very thick] (3.75, 0.5) -- ++(0.5, 0);

    
    % second row of U goes down
    \draw<18>[red,->,very thick] (2.5, 3.25) -- ++(0, -0.5);
    \draw<20>[red,->,very thick] (2.5, 3.25) -- ++(0, -1.5);
    \draw<22>[red,->,very thick] (2.5, 3.25) -- ++(0, -2.5);

    \draw<20>[red,->,very thick] (3.5, 3.25) -- ++(0, -0.5);
    \draw<22>[red,->,very thick] (3.5, 3.25) -- ++(0, -1.5);
    \draw<24>[red,->,very thick] (3.5, 3.25) -- ++(0, -2.5);

    \draw<22>[red,->,very thick] (4.5, 3.25) -- ++(0, -0.5);
    \draw<24>[red,->,very thick] (4.5, 3.25) -- ++(0, -1.5);
    \draw<26>[red,->,very thick] (4.5, 3.25) -- ++(0, -2.5);

    % third row of U goes down
    \draw<28>[red,->,very thick] (3.5, 2.25) -- ++(0, -0.5);
    \draw<30>[red,->,very thick] (3.5, 2.25) -- ++(0, -1.5);

    \draw<30>[red,->,very thick] (4.5, 2.25) -- ++(0, -0.5);
    \draw<32>[red,->,very thick] (4.5, 2.25) -- ++(0, -1.5);

    % fourth row of U goes down
    \draw<36>[red,->,very thick] (4.5, 1.25) -- ++(0, -0.5);

    % do 1st col
    \draw<2>[ultra thick] (0, 0) rectangle +(1, 5);
    \draw<14>[ultra thick] (1, 0) rectangle +(1, 4);
    \draw<24>[ultra thick] (2, 0) rectangle +(1, 3);
    \draw<32>[ultra thick] (3, 0) rectangle +(1, 2);
    \draw<38>[ultra thick] (4, 0) rectangle +(1, 1);
  \end{tikzpicture}
\end{column}

\begin{column}{6cm}
  \begin{block}{Remarks}
    \begin{itemize}
    \item 2D distribution of the matrix
    \item<2-> Proc. on a column cooperate: \red{panel factorization}
    \item<4-> Data flow (\red{pipeline})
    \item<14-> 2nd panel factorization
    \item<19-> 1st row/col now inactive
    \item<27-> 2nd row/col now inactive
    \end{itemize}
  \end{block}
\end{column}
\end{columns}

\begin{exampleblock}<39>{Distributed-memory LU}
  \begin{itemize}
  \item Uses 2D \red{cyclic} block distribution to keep everyone busy
  \item Implented in \texttt{HPL} , \texttt{ScaLAPACK}
  \item Major benchmark of HPC machines (``LINPACK'')
  \end{itemize}
\end{exampleblock}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Méthodes Iterative}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Iterative Methods in Linear Algebra}

  Important family of algorithms
  \begin{itemize}
  \item Solving $Ax = b$ or $Ax = \lambda x$
  \item Conjugate gradient, Lanczos, GMRES, etc.
  \end{itemize}

  \begin{block}{Principle}
    \begin{itemize}
    \item Choose an initial vector $x_0$
    \item Iterate the sequence $x_{i+1} = Ax$
    \item At each iteration, build an approximation of the solution
    \item Stop when the process has converged
      \begin{itemize}
      \item If it ever does...
      \end{itemize}
    \end{itemize}    
  \end{block}

  \begin{exampleblock}{Main point}
    
    \begin{itemize}
    \item Bulk of workload: \red{$y \gets Ax$}
      \begin{itemize}
      \item Matrix-vector product (\texttt{GEMV})
      \item Fast when $A$ is a \alert{\textbf{sparse matrix}}
      \end{itemize}
    \end{itemize}
  \end{exampleblock}  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Sparse Linear Algebra}

  \begin{itemize}
  \item Many physical situations yields \red{sparse} linear systems
  \item E.g. Finite Element Method
    \begin{center}
      \includegraphics[width=5cm]{fem_sample} \\
      {\tiny Image: (c) PyCAE} 
    \end{center}
    
  \item One variable per cell
  \item A single equation \red{only} relates variables of \red{neighboring} cells
  \item $Ax = b$ with \red{sparse} A (mostly zero coefficients)
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Sparse Matrices}

  \begin{block}{Goals when dealing with sparse matrices}
    \begin{itemize}
    \item Don't store 0
    \item Don't compute $0 + x$ and $0 \times x$
    \end{itemize}
  \end{block}
  
  \begin{center}
    \includegraphics[width=3cm]{sparse.png} \\
    {\tiny Image: (c) T. davis} 
  \end{center}
  
  \begin{block}{Most important parameter: \textbf{density}}
    \begin{itemize}
    \item Proportion of \red{non-zero} coefficients
    \item density $< 0.01$ (say) $\leadsto$ sparse
    \end{itemize}
  \end{block}
  
\end{frame}
  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile=singleslide]
  \frametitle{Matrix-Vector product (\texttt{GEMV})}
  \framesubtitle{$y \gets y + \alpha Ax$}
  \begin{alertblock}{Dense \texttt{GEMV}}
    \begin{itemize}
    \item All matrix coeffs are contiguous in memory
    \end{itemize}
    \vspace*{-2ex}
    \begin{minted}[fontsize=\small]{C}
for (int i = 0; i < n; i++)               // 3nm FLOP
    for (int j = 0; j < m; j++)
        y[i] += alpha * A[i*m + j] * x[j]; 
      \end{minted}
    \end{alertblock}
  
  \begin{exampleblock}{Sparse \texttt{GEMV}}
    \begin{itemize}
      \item Only $\texttt{nz} \lll nm$ non-zero coeffs
      \item Idea: store list of $(i, j, x)$ such that $A_{ij} = x$ (and $x \neq 0)$
        \begin{itemize}
        \item 3 arrays: \texttt{Ai}, \texttt{Aj}, \texttt{Ax}
        \item $k$-th coeff: $(\texttt{Ai[k]}, \texttt{Aj[k]}, \texttt{Ax[k]})$
        \end{itemize}
      \end{itemize}
      \vspace*{-2ex}
      \begin{minted}[fontsize=\small]{C}
for (int k = 0; k < nz; k++)              // 3nz FLOP
    y[Ai[k]] += alpha * Ax[k] * x[Aj[k]]; 
    \end{minted}
  \end{exampleblock}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\begin{frame}
  \frametitle{Recurring problem in HPC}

  \begin{block}{Iterative methods with sparse matrices}
    \begin{itemize}
    \item compute $x_{i+1} = A x_i$
    \item For $i=1, 2, 3,  4, 5, \dots$
    \item With large, sparse matrix $A$
    \item \red{In parallel}
      \begin{itemize}
      \item Need $x_{i+1}$ to start $x_{i+2}$
      \item Iterations are necessarily \red{sequential} 
      \item[$\Rightarrow$] Parallelize the \textbf{matrix-vector product}
      \end{itemize}
    \end{itemize}
  \end{block}  
  
  \begin{exampleblock}{Data parallelism}
    \begin{itemize}
    \item $A$ is \textbf{distributed} between processes (how?)
    \item $x_i$ is \textbf{distributed} between processes (how?)
    \item $x_{i+1}$ must be distributed \red{identically} to iterate
    \end{itemize}
  \end{exampleblock}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[label=1d]
  \frametitle{Distributed Matrix-Vector Product}
  \framesubtitle{1D block distribution (per rows)}

  \begin{block}{Data distribution}
    \begin{itemize}
    \item[$M$] : 1D block distribution (blocks of rows)
    \item[$x$] : owned by all processes
    \item[$y$] : owned by all processes
    \end{itemize}
  \end{block}


  \begin{center}
    \begin{tikzpicture}[>=latex]
      \path[red,dotted,use as bounding box] (0,0) rectangle (10, 4);
      \draw[<->] (-0.5,0) -- node[left] {$n$} +(0, 4);
  
      % matrix
      \draw[thick] (0,0) rectangle (4,4);
      \filldraw[fill=red]     (0, 3.5) rectangle +(4, 0.5);
      \filldraw[fill=orange]  (0, 3  ) rectangle +(4, 0.5);
      \filldraw[fill=yellow]  (0, 2.5) rectangle +(4, 0.5);
      \filldraw[fill=green]   (0, 2  ) rectangle +(4, 0.5);
      \filldraw[fill=cyan]    (0, 1.5) rectangle +(4, 0.5);
      \filldraw[fill=blue]    (0, 1  ) rectangle +(4, 0.5);
      \filldraw[fill=magenta] (0, 0.5) rectangle +(4, 0.5);
      \filldraw[fill=violet]  (0, 0  ) rectangle +(4, 0.5);
      
      \node[below] at (2,0) {$M$};

      \node at (4.25,2) {$\times$};
      
      \draw[thick,pattern=north east lines] (4.5,0) rectangle +(0.5,4);
      \node[below] at (4.75,0) {$x_i$};
      
      \draw[->] (5.25, 2) -- node[above,font=\small] {\texttt{GEMV}} +(1 ,0);

      \begin{scope}[xshift=0.5cm]
        \draw[thick] (6,0) rectangle +(0.5,4);
        \filldraw[fill=red]     (6, 3.5) rectangle +(0.5, 0.5);
        \filldraw[fill=orange]  (6, 3  ) rectangle +(0.5, 0.5);
        \filldraw[fill=yellow]  (6, 2.5) rectangle +(0.5, 0.5);
        \filldraw[fill=green]   (6, 2  ) rectangle +(0.5, 0.5);
        \filldraw[fill=cyan]    (6, 1.5) rectangle +(0.5, 0.5);
        \filldraw[fill=blue]    (6, 1  ) rectangle +(0.5, 0.5);
        \filldraw[fill=magenta] (6, 0.5) rectangle +(0.5, 0.5);
        \filldraw[fill=violet]  (6, 0  ) rectangle +(0.5, 0.5);
      \end{scope}

    \draw[->] (7.25, 2) -- node[above,font=\small] {\texttt{\texttt{MPI\_Allgather}}} +(2.5, 0);
      
      \draw[dashed] (6.5, 3) -- +(1, 0);
      \draw[dashed] (6.5, 3.5) -- +(1, 0);
      \draw[decorate,decoration={brace,mirror}] (7.5, 3) --  node[right=1mm] {size $\frac{n}{p}$} +(0, 0.5);

      % x_i+1
      \draw[thick,pattern=north east lines] (10,0) rectangle +(0.5,4);
      \node[below] at (10.25,0) {$x_{i+1}$};
    \end{tikzpicture}
  \end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[label=1d]
%  \frametitle{Distributed Matrix-Vector Product (1D per rows)}

  \begin{alertblock}{Machine parameters}
    \begin{itemize}
    \item $C$ = processor FLOP/s
    \item $D$ = network bandwidth (float / s)
    \end{itemize}
  \end{alertblock}

  \begin{exampleblock}{Matrix characteristics}
    \begin{itemize}
    \item $n$ = size
    \item $d$ = \emph{density} ($dn^2$ non-zero coeffs)
%    \item[$\Rightarrow$] $3 d n^2$ FLOP / iteration
    \end{itemize}
  \end{exampleblock}

  \begin{center}
    \begin{tabular}{|c||c|c|}
      \hline
      & \texttt{GEMV}  & \texttt{MPI\_Allgather} \\
      \hline\hline
      Sequential           & $3 d n^2 / C$ &    0 \\
      \hline
      Distributed          & $3 d n^2 / (pC)$ & $\geq n / D$ \\
      \hline
    \end{tabular}
  \end{center}

  \[
    \mathrm{Speedup} \leq \frac{d n^2}{C} / (\frac{d n^2}{pC} + \frac{n}{D}) \leq d n \frac{D}{C}
  \]

  \begin{itemize}
  \item $D/C$ = ``machine balance'' = very important
 \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\begin{frame}[label=1d]
  \frametitle{Communication Limits Acceleration}
  
  \begin{center}
    \begin{tikzpicture}[scale=0.5, >=latex, every node/.style={font=\scriptsize}]
      \draw[<->] (-0.5,0) -- node[left] {$n$} +(0, 4);
  
      % matrix
      \draw[thick] (0,0) rectangle (4,4);
      \filldraw[fill=red]     (0, 3.5) rectangle +(4, 0.5);
      \filldraw[fill=orange]  (0, 3  ) rectangle +(4, 0.5);
      \filldraw[fill=yellow]  (0, 2.5) rectangle +(4, 0.5);
      \filldraw[fill=green]   (0, 2  ) rectangle +(4, 0.5);
      \filldraw[fill=cyan]    (0, 1.5) rectangle +(4, 0.5);
      \filldraw[fill=blue]    (0, 1  ) rectangle +(4, 0.5);
      \filldraw[fill=magenta] (0, 0.5) rectangle +(4, 0.5);
      \filldraw[fill=violet]  (0, 0  ) rectangle +(4, 0.5);
      
      \node[below] at (2,0) {$M$};

      \node at (4.25,2) {$\times$};
      
      \draw[thick,pattern=north east lines] (4.5,0) rectangle +(0.5,4);
      \node[below] at (4.75,0) {$x_i$};
      
      \draw[->] (5.25, 2) -- node[above,font=\scriptsize] {\texttt{GEMV}} +(2 ,0);

      \begin{scope}[xshift=7.5cm]
        \draw[thick] (0,0) rectangle +(0.5,4);
        \filldraw[fill=red]     (0, 3.5) rectangle +(0.5, 0.5);
        \filldraw[fill=orange]  (0, 3  ) rectangle +(0.5, 0.5);
        \filldraw[fill=yellow]  (0, 2.5) rectangle +(0.5, 0.5);
        \filldraw[fill=green]   (0, 2  ) rectangle +(0.5, 0.5);
        \filldraw[fill=cyan]    (0, 1.5) rectangle +(0.5, 0.5);
        \filldraw[fill=blue]    (0, 1  ) rectangle +(0.5, 0.5);
        \filldraw[fill=magenta] (0, 0.5) rectangle +(0.5, 0.5);
        \filldraw[fill=violet]  (0, 0  ) rectangle +(0.5, 0.5);
      \end{scope}

    \draw[->] (8.25, 2) -- node[above,font=\scriptsize] {\texttt{MPI\_Allgather}} +(4.5, 0);
      
      % x_i+1
      \draw[thick,pattern=north east lines] (13,0) rectangle +(0.5,4);
      \node[below] at (13.25,0) {$x_{i+1}$};
    \end{tikzpicture}
  \end{center}

\vspace{0.5cm}
  
\begin{tikzpicture}
    \node<1> at (1, 2) {$p=1$};
    \node<2> at (1, 2) {$p=2$};
    \node<3> at (1, 2) {$p=4$};
    \node<4> at (1, 2) {$p=20$};
    
    \draw[thick, ->] (-0.5, 0) -- (8.5, 0) node[right] {time};

    
    \foreach \i in {0, 1, 2, 3}  {
      \fill<1>[fill=LimeGreen, nearly transparent] (\i*2cm, -0.25) rectangle +(2, 0.5);
    }
    \foreach \i in {0, 1, 2, 3, 4} {
      \draw<1>[thick] (\i*2cm, -0.1) -- +(0, 0.2);
      \node<1>[anchor=south] at (\i*2cm, 0.25) {$x_\i$};
    }

    % p = 2
    \foreach \i in {0, 1, 2, 3, 4}  {
      \fill<2>[fill=LimeGreen, nearly transparent] (\i*1.5cm, -0.25) rectangle +(1, 0.5);
      \fill<2>[fill=red, nearly transparent] (\i*1.5cm, 0) +(1, -0.25) rectangle +(1.5, 0.25);
    }
    \foreach \i in {0, 1, 2, 3, 4, 5} {
      \draw<2>[thick] (\i*1.5cm, -0.1) -- +(0, 0.2);
      \node<2>[anchor=south] at (\i*1.5cm, 0.25) {$x_\i$};
    }

    % p = 4
    \foreach \i in {0, 1, 2, ..., 7}  {
      \fill<3>[fill=LimeGreen, nearly transparent] (\i*1cm, -0.25) rectangle +(0.5, 0.5);
      \fill<3>[fill=red, nearly transparent] (\i*1cm+0.5cm, -0.25)  rectangle +(0.5, 0.5);
    }
    \foreach \i in {0, 1, ..., 8} {
      \draw<3>[thick] (\i*1cm, -0.1) -- +(0, 0.2);
      \node<3>[anchor=south] at (\i*1cm, 0.25) {$x_\i$};
    }

    % p = 20
    \foreach \i in {0, 1, 2, ..., 12}  {
      \fill<4>[fill=LimeGreen, nearly transparent] (\i*0.6cm, -0.25) rectangle +(0.1, 0.5);
      \fill<4>[fill=red, nearly transparent] (\i*0.6cm+0.1cm, -0.25)  rectangle +(0.5, 0.5);
    }
    \foreach \i in {0, 1, ..., 13} {
      \draw<4>[thick] (\i*0.6cm, -0.1) -- +(0, 0.2);
      \node<4>[anchor=south] at (\i*0.6cm, 0.25) {$x_{\i}$};
    }

    
    \fill[fill=LimeGreen, nearly transparent] (1, -1) rectangle +(1, 0.5);
    \path (1, -1) rectangle node[font=\small] {\texttt{GEMV}} +(1, 0.5);

    \fill[fill=red, nearly transparent] (1, -1.5) rectangle +(3, 0.5);
    \path (1, -1.5) rectangle node[font=\small] {\texttt{MPI\_AllGather}} +(3, 0.5);
  \end{tikzpicture}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\begin{frame}
  \frametitle{Distributed Matrix-Vector Product}
  \framesubtitle{1D block distribution (per columns)}

  \begin{block}{Data distribution}
    \begin{itemize}
    \item[$M$] : 1D block distribution (blocks of columnss)
    \item[$x$] : 1D block distribution
    \item[$y$] : 1D block distribution
    \end{itemize}
  \end{block}


  \begin{center}
    \begin{tikzpicture}[>=latex]
      \path[red,dotted,use as bounding box] (0,0) rectangle (10, 4);
      \draw[<->] (-0.5,0) -- node[left] {$n$} +(0, 4);
  
      % matrix
      \draw[thick] (0,0) rectangle (4,4);
      \filldraw[fill=red]     (0  , 0) rectangle +(0.5, 4);
      \filldraw[fill=orange]  (0.5, 0) rectangle +(0.5, 4);
      \filldraw[fill=yellow]  (1.0, 0) rectangle +(0.5, 4);
      \filldraw[fill=green]   (1.5, 0) rectangle +(0.5, 4);
      \filldraw[fill=cyan]    (2.0, 0) rectangle +(0.5, 4);
      \filldraw[fill=blue]    (2.5, 0) rectangle +(0.5, 4);
      \filldraw[fill=magenta] (3.0, 0) rectangle +(0.5, 4);
      \filldraw[fill=violet]  (3.5, 0) rectangle +(0.5, 4);
      
      \node[below] at (2,0) {$M$};

      \node at (4.25,2) {$\times$};
      
      \begin{scope}[xshift=4.5cm]
        \draw[thick] (0,0) rectangle +(0.5,4);
        \filldraw[fill=red]     (0, 3.5) rectangle +(0.5, 0.5);
        \filldraw[fill=orange]  (0, 3  ) rectangle +(0.5, 0.5);
        \filldraw[fill=yellow]  (0, 2.5) rectangle +(0.5, 0.5);
        \filldraw[fill=green]   (0, 2  ) rectangle +(0.5, 0.5);
        \filldraw[fill=cyan]    (0, 1.5) rectangle +(0.5, 0.5);
        \filldraw[fill=blue]    (0, 1  ) rectangle +(0.5, 0.5);
        \filldraw[fill=magenta] (0, 0.5) rectangle +(0.5, 0.5);
        \filldraw[fill=violet]  (0, 0  ) rectangle +(0.5, 0.5);
      \end{scope}

      \node[below] at (4.75,0) {$x_i$};
      
      \draw[->] (5.25, 2) -- node[above,font=\small] {\texttt{GEMV}} +(1 ,0);

      \draw[thick,fill=gray] (6.5,0) rectangle +(0.5,4);
      \node[below] at (6.75,0) {\tiny partial sums};

      
      \draw[->] (7.25, 2) -- node[above,font=\small] {\texttt{\texttt{Reduce\_Scatter}}} +(2.5, 0);
      
      % x_i+1
      \begin{scope}[xshift=10cm]
        \draw[thick] (0,0) rectangle +(0.5,4);
        \filldraw[fill=red]     (0, 3.5) rectangle +(0.5, 0.5);
        \filldraw[fill=orange]  (0, 3  ) rectangle +(0.5, 0.5);
        \filldraw[fill=yellow]  (0, 2.5) rectangle +(0.5, 0.5);
        \filldraw[fill=green]   (0, 2  ) rectangle +(0.5, 0.5);
        \filldraw[fill=cyan]    (0, 1.5) rectangle +(0.5, 0.5);
        \filldraw[fill=blue]    (0, 1  ) rectangle +(0.5, 0.5);
        \filldraw[fill=magenta] (0, 0.5) rectangle +(0.5, 0.5);
        \filldraw[fill=violet]  (0, 0  ) rectangle +(0.5, 0.5);
      \end{scope}


      \node[below] at (10.25,0) {$x_{i+1}$};
    \end{tikzpicture}
  \end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile=singleslide]
\frametitle{MPI : Reduce-Scatter}

  \begin{wider}
\begin{minted}[fontsize=\footnotesize]{C}
int MPI_Reduce_scatter_block(void* sendbuf, void* recvbuf,
                             int recvcount, MPI_Datatype datatype,
                             MPI_Op op, MPI_Comm comm)
\end{minted}
  \end{wider}

  \bigskip

  \begin{center}
    \begin{tikzpicture}[scale=0.5, >=latex]
            \begin{scope}
        \foreach \letter / \i in {a / 0, b / 1, c / 2, d / 3, e / 4, f / 5} {
          \draw[thick] (1.2*\i, 0) rectangle +(1, 6);
          \foreach \j in {1,...,5} {
            \draw[thick] (1.2*\i, \j) -- +(1, 0);
          }
          \node at (1.2*\i + 0.5, 6.5) {$P_\i$};          
          \node at (0.5 + 1.2*\i, 5.5) {$\scriptscriptstyle \sum \letter_i$};
        }
      \end{scope}

      \draw[ultra thick,<-] (8, 3) -- node[above] {Reduce-Scatter} (12, 3);

      \begin{scope}[xshift=13cm]
        \foreach \letter / \i in {a / 0, b / 1, c / 2, d / 3, e / 4, f / 5} {
          \draw[thick] (1.2*\i, 0) rectangle +(1, 6);
          \foreach \j in {1,...,5} {
            \draw[thick] (1.2*\i, \j) -- +(1, 0);
          }
          \node at (1.2*\i + 0.5, 6.5) {$P_\i$};
          \foreach \j in {0,1,...,5} {
            \node<1> at (0.5 + 1.2*\j,  5.5 - \i) {$\letter_\j$};
          }
        }
      \end{scope}
\end{tikzpicture}
\end{center}

\begin{itemize}
\item Lower bound: $T \geq \lceil \log_2 p \rceil \alpha + (p-1) \frac{n}{p} \beta$
\item Ring algorithm: $T = (p-1) (\alpha + \frac{n}{p} \beta)$
\end{itemize}

\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[label=2d]
  \frametitle{Distributed Matrix-Vector Product}
  \framesubtitle{2D block distribution}

  \begin{block}{Data distribution}
    \begin{itemize}
    \item[$M$] : 2D block distribution ($v \times h$ blocks)
    \item[$x$] : 1D block distribution 
    \item[$y$] : 1D block distribution
    \end{itemize}
  \end{block}

  \begin{center}
    \begin{tikzpicture}[>=latex, scale=0.7]
      \begin{scope}[xshift=-4cm, yscale=2, xscale=1.333]
        \draw[thick] (0,0) rectangle (4,2);
        \foreach \i in {1, 2, ..., 11} {
          \draw (-0.1, \i/4) -- (0, \i/4);
          \draw (\i/3, -0.1) -- (\i/3, 0);
          \draw (4.1, \i/4) -- (4, \i/4);
          \draw (\i/3, 3.1) -- (\i/3, 3);
        }
      \filldraw[fill=brown]    (0, 2) rectangle node {0} +(1, 1);
      \filldraw[fill=orange]   (1, 2) rectangle  node {3} +(1, 1);
      \filldraw[fill=red]      (2, 2) rectangle  node {6} +(1, 1);
      \filldraw[fill=purple]   (3, 2) rectangle  node {9} +(1, 1);
      \filldraw[fill=magenta]  (0, 1) rectangle  node {1} +(1, 1);
      \filldraw[fill=violet]   (1, 1) rectangle  node {4} +(1, 1);
      \filldraw[fill=blue]     (2, 1) rectangle  node {7} +(1, 1);
      \filldraw[fill=teal]     (3, 1) rectangle  node {10} +(1, 1);
      \filldraw[fill=cyan]     (0, 0) rectangle  node {2} +(1, 1);
      \filldraw[fill=green]    (1, 0) rectangle  node {5} +(1, 1);
      \filldraw[fill=lime]     (2, 0) rectangle  node {8} +(1, 1);
      \filldraw[fill=yellow]   (3, 0) rectangle  node {11} +(1, 1);

      \node[below] at (2,0) {$M$};
    \end{scope}

    \node at (2.25, 3) {$\times$};

          \begin{scope}[xshift=-1cm]
      \draw[thick] (4.5,0) rectangle +(0.5, 6);
      \filldraw[fill=brown]    (4.5, 5.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=magenta]   (4.5, 5) rectangle     +(0.5, 0.5);
      \filldraw[fill=cyan]     (4.5, 4.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=orange]    (4.5, 4) rectangle     +(0.5, 0.5);
      \filldraw[fill=violet]  (4.5, 3.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=green]   (4.5, 3) rectangle     +(0.5, 0.5);
      \filldraw[fill=red]     (4.5, 2.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=blue]     (4.5, 2) rectangle     +(0.5, 0.5);
      \filldraw[fill=lime]      (4.5, 1.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=purple]    (4.5, 1) rectangle     +(0.5, 0.5);
      \filldraw[fill=teal]     (4.5, 0.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=yellow]   (4.5, 0) rectangle     +(0.5, 0.5);
      \node[below] at (4.75,0) {$x_i$};
    \end{scope}
    \draw[->] (4.25, 3) -- +(1,0);
      
      \begin{scope}[xshift=1cm]
              \draw[thick] (4.5,0) rectangle +(0.5, 6);
      \filldraw[fill=brown]    (4.5, 5.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=magenta]   (4.5, 5) rectangle     +(0.5, 0.5);
      \filldraw[fill=cyan]     (4.5, 4.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=orange]    (4.5, 4) rectangle     +(0.5, 0.5);
      \filldraw[fill=violet]  (4.5, 3.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=green]   (4.5, 3) rectangle     +(0.5, 0.5);
      \filldraw[fill=red]     (4.5, 2.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=blue]     (4.5, 2) rectangle     +(0.5, 0.5);
      \filldraw[fill=lime]      (4.5, 1.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=purple]    (4.5, 1) rectangle     +(0.5, 0.5);
      \filldraw[fill=teal]     (4.5, 0.5) rectangle   +(0.5, 0.5);
      \filldraw[fill=yellow]   (4.5, 0) rectangle     +(0.5, 0.5);
      \node[below] at (4.75,0) {$x_{i+1}$};
    \end{scope}

  \end{tikzpicture}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[label=2d]
  \begin{columns}
    \begin{column}{6cm}
    \begin{tikzpicture}[>=latex,scale=0.4]
      \begin{scope}[xshift=-4cm, yscale=2, xscale=1.5]
        \foreach \i in {1, 2, ..., 11} {
          \draw (-0.1, \i/4) -- (0, \i/4);
          \draw (\i/3, -0.1) -- (\i/3, 0);
          \draw (4.1, \i/4) -- (4, \i/4);
          \draw (\i/3, 3.1) -- (\i/3, 3);
        }
      \filldraw[fill=brown]    (0, 2) rectangle node {0} +(1, 1);
      \filldraw[fill=orange]   (1, 2) rectangle  node {3} +(1, 1);
      \filldraw[fill=red]      (2, 2) rectangle  node {6} +(1, 1);
      \filldraw[fill=purple]   (3, 2) rectangle  node {9} +(1, 1);
      \filldraw[fill=magenta]  (0, 1) rectangle  node {1} +(1, 1);
      \filldraw[fill=violet]   (1, 1) rectangle  node {4} +(1, 1);
      \filldraw[fill=blue]     (2, 1) rectangle  node {7} +(1, 1);
      \filldraw[fill=teal]     (3, 1) rectangle  node {10} +(1, 1);
      \filldraw[fill=cyan]     (0, 0) rectangle  node {2} +(1, 1);
      \filldraw[fill=green]    (1, 0) rectangle  node {5} +(1, 1);
      \filldraw[fill=lime]     (2, 0) rectangle  node {8} +(1, 1);
      \filldraw[fill=yellow]   (3, 0) rectangle  node {11} +(1, 1);
      \draw[thick] (0,0) rectangle (4, 3);
      
      \draw<2>[pattern=north east lines] (0, 2) rectangle  +(1/3, 1);
      \draw<2>[pattern=north east lines] (1, 2) rectangle  +(1/3, 1);
      \draw<2>[pattern=north east lines] (2, 2) rectangle  +(1/3, 1);
      \draw<2>[pattern=north east lines] (3,   2) rectangle  +(1/3, 1);
      \draw<2>[pattern=north east lines] (1/3, 1) rectangle  +(1/3, 1);
      \draw<2>[pattern=north east lines] (1+1/3, 1) rectangle  +(1/3, 1);
      \draw<2>[pattern=north east lines] (2+1/3, 1) rectangle  +(1/3, 1);
      \draw<2>[pattern=north east lines] (3+1/3, 1) rectangle  +(1/3, 1);
      \draw<2>[pattern=north east lines] (0+2/3, 0) rectangle  +(1/3, 1);
      \draw<2>[pattern=north east lines] (1+2/3, 0) rectangle  +(1/3, 1);
      \draw<2>[pattern=north east lines] (2+2/3, 0) rectangle  +(1/3, 1);
      \draw<2>[pattern=north east lines] (3+2/3, 0) rectangle  +(1/3, 1);

      \node[below] at (2,0) {$M$};
    \end{scope}

    \begin{onlyenv}<9-10>
      \begin{scope}[xshift=4cm, yscale=2, xscale=1.5]
        \foreach \i in {1, 2, ..., 11} {
          \draw (-0.1, \i/4) -- (0, \i/4);
          \draw (\i/3, -0.1) -- (\i/3, 0);
          \draw (4.1, \i/4) -- (4, \i/4);
          \draw (\i/3, 3.1) -- (\i/3, 3);
        }
      \filldraw[fill=brown]    (0, 2) rectangle node {0} +(1, 1);
      \filldraw[fill=magenta]  (1, 2) rectangle  node {1} +(1, 1);
      \filldraw[fill=cyan]     (2, 2) rectangle  node {2} +(1, 1);      
      \filldraw[fill=orange]   (3, 2) rectangle  node {3} +(1, 1);
      
      \filldraw[fill=violet]   (0, 1) rectangle  node {4} +(1, 1);
      \filldraw[fill=green]    (1, 1) rectangle  node {5} +(1, 1);
      \filldraw[fill=red]      (2, 1) rectangle  node {6} +(1, 1);
      \filldraw[fill=blue]     (3, 1) rectangle  node {7} +(1, 1);
      
      \filldraw[fill=lime]     (0, 0) rectangle  node {8} +(1, 1);
      \filldraw[fill=purple]   (1, 0) rectangle  node {9} +(1, 1);
      \filldraw[fill=teal]     (2, 0) rectangle  node {10} +(1, 1);
      \filldraw[fill=yellow]   (3, 0) rectangle  node {11} +(1, 1);
      \draw[thick] (0,0) rectangle (4, 3);
    \end{scope}
  \end{onlyenv}
\end{tikzpicture}

    \begin{block}{Algorithm}
      \begin{itemize}
      \item<3-> \texttt{MPI\_Allgather}
      \item<5-> \texttt{GEMV} (partial sums)
      \item<7-> \texttt{MPI\_reduce\_scatter}
      \item<10-> \texttt{MPI\_sendrecv} (transpose)

      \end{itemize}
    \end{block}
  \end{column}

  \begin{column}{4cm}
    \begin{tikzpicture}[>=latex, yscale=0.45, xscale=0.5]
      % cadre
      \foreach \i in {0, 1, 2, 3} {
        \foreach \j in {0, 1, 2} {
          \draw[thick] (\i, 6.5*\j) rectangle +(0.5, 6);
          \foreach \k in {1, 2, ..., 11} {
            \draw (\i, 6.5*\j) ++(0, 0.5*\k) -- ++(0.5, 0);
          }
        }
      }

      % placement initial
      \foreach \i in {0, 1, 2, 3} {
        \foreach \j in {0, 1, 2} {
          \filldraw<1-3>[fill=black]  (\i, 3*6 + 0.5 - 1.5*\i - 7*\j)  rectangle +(0.5, 0.5);
        }
      }

      % Allgather colonnes arrows
      \draw<3>[red, very thick, <->] (0.25, 5.25 + 2*6.5) -- +(0, -6);
      \draw<3>[red, very thick, <->] (0.25, 4.75 + 1*6.5) -- +(0, -6);
      \draw<3>[red, very thick, <->] (1.25, 3.75 + 2*6.5) -- +(0, -6);
      \draw<3>[red, very thick, <->] (1.25, 3.25 + 1*6.5) -- +(0, -6);
      \draw<3>[red, very thick, <->] (2.25, 2.25 + 2*6.5) -- +(0, -6);
      \draw<3>[red, very thick, <->] (2.25, 1.75 + 1*6.5) -- +(0, -6);
      \draw<3>[red, very thick, <->] (3.25, 0.75 + 2*6.5) -- +(0, -6);
      \draw<3>[red, very thick, <->] (3.25, 0.25 + 1*6.5) -- +(0, -6);

      % allgather result
      \foreach \i in {0, 1, 2, 3} {
        \foreach \j in {0, 1, 2} {
          \filldraw<4>[fill=black]  (\i, 3*6 - 0.5 - 1.5*\i - 6.5*\j)  rectangle +(0.5, 1.5);
        }
      }

      % prepare GEMM
      \filldraw<5>[fill=brown]       (0, 17.5)   rectangle +(0.5, 1.5);
      \filldraw<5>[fill=orange]      (1, 16) rectangle +(0.5, 1.5);
      \filldraw<5>[fill=red]         (2, 14.5)   rectangle +(0.5, 1.5);
      \filldraw<5>[fill=purple]      (3, 13)   rectangle +(0.5, 1.5);
      \filldraw<5>[fill=magenta]     (0, 11)    rectangle +(0.5, 1.5);
      \filldraw<5>[fill=violet]      (1, 9.5)  rectangle +(0.5, 1.5);
      \filldraw<5>[fill=blue]        (2, 8)    rectangle +(0.5, 1.5);
      \filldraw<5>[fill=teal]        (3, 6.5)    rectangle +(0.5, 1.5);
      \filldraw<5>[fill=cyan]        (0, 4.5)    rectangle +(0.5, 1.5);
      \filldraw<5>[fill=green]       (1, 3)  rectangle +(0.5, 1.5);
      \filldraw<5>[fill=lime]        (2, 1.5)    rectangle +(0.5, 1.5);
      \filldraw<5>[fill=yellow]      (3, 0)    rectangle +(0.5, 1.5);


      % GEMM result
      \foreach \i in {0, 1, 2, 3} {
        \foreach \j in {0, 1, 2} {
          \filldraw<6-7>[fill=gray]  (\i, 2*\j + 6.5*\j)  rectangle +(0.5, 2);
        }
      }

      % Reduce-scatter arrow
      \foreach \i in {0, 1, 2, 3} {
        \foreach \j in {0, 1, 2} {
          \draw<7>[red,very thick, <->]  (0, 0.25 + 8.5*\j + 0.5*\i) -- +(3.5, 0);
        }
      }

      % placement après RS
      \foreach \i in {0, 1, 2, 3} {
        \foreach \j in {0, 1, 2} {
          \filldraw<8-10>[fill=black]  (\i, 1.5 - 0.5*\i +2*\j + 6.5*\j)  rectangle +(0.5, 0.5);
        }
      }

      % transposition
      \draw<10>[red, very thick,->]  (1.25, 5.25 + 2*6.5)  --  (0.25, 5.25 + 1*6.5);
      \draw<10>[red, very thick,->]  (2.25, 4.75 + 2*6.5)  --  (0.25, 4.75 + 0*6.5);
      \draw<10>[red, very thick,->]  (3.25, 4.25 + 2*6.5)  --  (1.25, 4.25 + 2*6.5);
      \draw<10>[red, very thick,->]  (0.25, 3.75 + 1*6.5)  --  (1.25, 3.75 + 1*6.5);
      \draw<10>[red, very thick,->]  (1.25, 3.25 + 1*6.5)  --  (1.25, 3.25 + 0*6.5);
      \draw<10>[red, very thick,->]  (2.25, 2.75 + 1*6.5)  --  (2.25, 2.75 + 2*6.5);
      \draw<10>[red, very thick,->]  (3.25, 2.25 + 1*6.5)  --  (2.25, 2.25 + 1*6.5);
      \draw<10>[red, very thick,->]  (0.25, 1.75 + 0*6.5)  --  (2.25, 1.75 + 0*6.5);
      \draw<10>[red, very thick,->]  (1.25, 1.25 + 0*6.5)  --  (3.25, 1.25 + 2*6.5);
      \draw<10>[red, very thick,->]  (2.25, 0.75 + 0*6.5)  --  (3.25, 0.75 + 1*6.5);

      % retour au placement initial
      \foreach \i in {0, 1, 2, 3} {
        \foreach \j in {0, 1, 2} {
          \filldraw<11>[fill=black]  (\i, 3*6 + 0.5 - 1.5*\i - 7*\j)  rectangle +(0.5, 0.5);
        }
      }
    \end{tikzpicture}
  \end{column}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[label=2d]
  \frametitle{Analysis}

  Process grid of size $v \times h$
  
  \begin{center}
    \begin{tabular}{|c||c|c|}
      \hline
      & Sequential & Distributed \\
      \hline\hline
      \texttt{GEMV}                 & $3 d n^2 / C$ & $3 d n^2 / (vhC)$ \\
      \hline
      \texttt{MPI\_Allgather}       & 0             & $n / (hD)$ \\
      \hline
      \texttt{MPI\_reduce\_scatter} & 0             & $n / (vD)$ \\
      \hline
      \texttt{MPI\_sendrecv}        & 0             & $n / (vhD)$ \\
      \hline
    \end{tabular}
  \end{center}

  Assume $v = h = \sqrt{p}$ and \alert{ignore latencies}:
  
  \[
    \mathrm{Speedup} = \frac{d n^2}{C} / (\frac{d n^2}{pC} + \frac{n}{D\sqrt{p}})
  \]

  \begin{alertblock}{Progress}
    \begin{itemize}
    \item Communication time \textbf{also decreases} when $p$ grows
    \item Speed-up \textbf{no longer bounded} when $p$ grows
    \end{itemize}
  \end{alertblock}
  
\end{frame}


\end{document}






% Charles' emacs magic commands
%%% Local Variables:
%%% TeX-engine: xetex
%%% TeX-command-extra: "-shell-escape"
%%% TeX-command-extra-options: "-shell-escape"
%%% ispell-local-dictionary: "english"
%%% eval: (flyspell-mode 1)
%%% eval: (reftex-mode 1)
%%% End:
